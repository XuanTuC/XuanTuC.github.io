<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><!-- hexo injector head_begin start -->
<link rel="stylesheet" href="/css/bilicard.css">
<!-- hexo injector head_begin end --><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>数据结构算法总结 | Hack_Peony 黑牡丹结社</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>数据结构算法总结</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-03-05T14:09:02.369Z" id="date"> 2023-03-05</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-05-22T08:16:01.571Z" id="updated"> 2023-05-22</time></div></span></div></div><hr><div id="post-content"><h1 id="一"><a href="#一" class="headerlink" title="一"></a><strong>一</strong></h1><p>假设以带头结点的循环链表表示一个队列 并只设一个指针指向队尾元素结点，用C语言编写相应的队列初始化、入队列和出队列的算法<br>以下是使用带头结点的循环链表表示队列的C语言代码，包括队列初始化、入队列和出队列的算法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 定义队列元素结构体</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct node *next;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">// 定义队列结构体</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  Node *rear; // 指向队尾元素结点</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line">// 初始化队列</span><br><span class="line">void InitQueue(Queue *q) &#123;</span><br><span class="line">  q-&gt;rear = (Node *)malloc(sizeof(Node)); // 创建头结点</span><br><span class="line">  q-&gt;rear-&gt;next = q-&gt;rear; // 头结点的next指针指向头结点本身，表示链表为空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入队列</span><br><span class="line">void EnQueue(Queue *q, int data) &#123;</span><br><span class="line">  Node *new_node = (Node *)malloc(sizeof(Node)); // 创建新结点</span><br><span class="line">  new_node-&gt;data = data;</span><br><span class="line">  new_node-&gt;next = q-&gt;rear-&gt;next; // 新结点的next指针指向头结点，保持循环链表特性</span><br><span class="line">  q-&gt;rear-&gt;next = new_node; // 队尾元素结点的next指针指向新结点</span><br><span class="line">  q-&gt;rear = new_node; // 更新队尾指针为新结点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出队列</span><br><span class="line">int DeQueue(Queue *q) &#123;</span><br><span class="line">  <span class="keyword">if</span> (q-&gt;rear-&gt;next == q-&gt;rear) &#123; // 队列为空，不能出队列</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">  &#125;</span><br><span class="line">  Node *first_node = q-&gt;rear-&gt;next-&gt;next; // 获取队头元素结点</span><br><span class="line">  int data = first_node-&gt;data; // 保存队头元素的数据</span><br><span class="line">  q-&gt;rear-&gt;next-&gt;next = first_node-&gt;next; // 队头元素结点从队列中移除</span><br><span class="line">  <span class="keyword">if</span> (first_node == q-&gt;rear) &#123; // 队列中只有一个元素时，出队列后队列为空</span><br><span class="line">    q-&gt;rear = q-&gt;rear-&gt;next; // 队尾指针指向头结点</span><br><span class="line">  &#125;</span><br><span class="line">  free(first_node); // 释放队头元素结点的内存空间</span><br><span class="line">  <span class="built_in">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二"><a href="#二" class="headerlink" title="二"></a><strong>二</strong></h1><p>、希望循环队列中的元素都得到运用，现在需要设置一个标志域tag，以tag的值为0还是1来区分，尾指针和头指针值相同时的队列元素是空还是满，试编写与此结构相应的入队和出队算法</p>
<p>以下是循环队列的入队和出队算法，使用一个标志位tag表示队列的状态，0表示队列为空，1表示队列为满。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">入队算法：</span><br><span class="line">void Enqueue(int* queue, int queue_size, int* rear, int* tag, int element) &#123;</span><br><span class="line"> // 判断队列是否为满</span><br><span class="line"> <span class="keyword">if</span> (*tag == 1 &amp;&amp; (*rear + 1) % queue_size == *front) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Queue is full.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> // 将元素插入队列尾</span><br><span class="line"> queue[*rear] = element;</span><br><span class="line"> // 移动队列尾指针</span><br><span class="line"> *rear = (*rear + 1) % queue_size;</span><br><span class="line"> // 如果队列尾指针等于队列头指针，表示队列已满</span><br><span class="line"> <span class="keyword">if</span> (*rear == *front) &#123;</span><br><span class="line">  *tag = 1;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">出队算法：</span><br><span class="line">int Dequeue(int* queue, int queue_size, int* front, int* rear, int* tag) &#123;</span><br><span class="line"> // 判断队列是否为空</span><br><span class="line"> <span class="keyword">if</span> (*tag == 0 &amp;&amp; *front == *rear) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">return</span> -1;</span><br><span class="line"> &#125;</span><br><span class="line"> // 取出队列头元素</span><br><span class="line"> int element = queue[*front];</span><br><span class="line"> // 移动队列头指针</span><br><span class="line"> *front = (*front + 1) % queue_size;</span><br><span class="line"> // 如果队列头指针等于队列尾指针，表示队列已空</span><br><span class="line"> <span class="keyword">if</span> (*front == *rear) &#123;</span><br><span class="line">  *tag = 0;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里的参数说明：</p>
<p>queue：指向循环队列数组的指针<br>queue_size：循环队列的大小<br>front：指向队列头的指针<br>rear：指向队列尾的指针<br>tag：队列状态的标志位<br>element：待入队或待出队的元素<br>在入队算法中，首先判断队列是否为满，如果队列已满则直接返回。否则将元素插入队列尾，并将队列尾指针后移一位。如果队列头指针等于队列尾指针，表示队列已满，将标志位tag设置为1。</p>
<p>在出队算法中，首先判断队列是否为空，如果队列为空则直接返回。否则取出队列头元素，并将队列头指针后移一位。如果队列头指针等于队列尾指针，表示队列已空，将标志位tag设置为0。最后返回取出的元素</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a><strong>三</strong></h1><p>利用线性表的顺序存储结构完成一个班级的一个学期的所有课程的管理，要求实现：增加、删除、修改学生的成绩记录等功能。线性表的长度设为全班的人数（35人），一个学期的课程设为3门，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include  &lt;stdio.h&gt;</span><br><span class="line">#include  &lt;stdlib.h&gt;</span><br><span class="line">#include  &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define Max_length  2</span><br><span class="line">typedef  struct &#123;</span><br><span class="line">	int  xh;         /* 学号 */</span><br><span class="line">	char  n[10];  /* 姓名 */</span><br><span class="line">	int   c1, c2, c3;  /* 3门课程成绩 */</span><br><span class="line">&#125; Element;</span><br><span class="line">/* 在第i个记录的后面插入一个学生的记录算法 */</span><br><span class="line">int Insert_list(int i, Element s[], int* n_pointer) &#123;</span><br><span class="line">	/* n_pointer存放已输入的最大记录数 */</span><br><span class="line">	int j, n;</span><br><span class="line">	n = *n_pointer;</span><br><span class="line">	if ((n == Max_length) || (i &lt; 1) || (i &gt; n + 1)) return (0);</span><br><span class="line">	for (j = n; j &gt;= i; j--) s[j + 1] = s[j];   /* 移动 */</span><br><span class="line">	printf(&quot;Input Data for inserting（XH  Name  C1  C2  C3）\n&quot;);</span><br><span class="line">	scanf_s(&quot;%d %s %d %d %d&quot;, &amp;s[i].xh, &amp;s[i].n,20, &amp;s[i].c1, &amp;s[i].c2, &amp;s[i].c3);</span><br><span class="line">	n++;  *n_pointer = n; 	return (1);</span><br><span class="line">&#125;</span><br><span class="line">/* 删除第i个学生的记录算法 */</span><br><span class="line">int Delete_list(int i, Element s[], int* n_pointer) &#123;</span><br><span class="line">	int j, n;</span><br><span class="line">	n = *n_pointer;</span><br><span class="line">	if ((i &lt; 1) || (i &gt; n))  return (0);</span><br><span class="line">	for (j = i + 1; j &lt;= n; j++) &#123; /* 移动 */</span><br><span class="line">		s[j - 1].xh = s[j].xh; 	strcpy_s(s[j - 1].n, s[j].n);</span><br><span class="line">		s[j - 1].c1 = s[j].c1;  	s[j - 1].c2 = s[j].c2; 	s[j - 1].c3 = s[j].c3;</span><br><span class="line">	&#125;</span><br><span class="line">	n--;  *n_pointer = n;  return (1);</span><br><span class="line">&#125;</span><br><span class="line">/* 查找学号为x算法 */</span><br><span class="line">int Locate_list(Element s[], int n, int x) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 1; i &lt;= n; i++)  if (s[i].xh == x) return (i);</span><br><span class="line">	return (0);</span><br><span class="line">&#125;</span><br><span class="line">/* 修改学号为i的学生的记录函数 */</span><br><span class="line">int Change_list(int i, Element s[]) &#123;</span><br><span class="line">	if ((i &lt; 1) || (i &gt; Max_length + 1)) return (0);</span><br><span class="line">	printf(&quot;Input data for updating:\n&quot;);</span><br><span class="line">	scanf_s(&quot; %d %s %d %d %d&quot;, &amp;s[i].xh, &amp;s[i].n,20, &amp;s[i].c1, &amp;s[i].c2, &amp;s[i].c3);</span><br><span class="line">	return (1);</span><br><span class="line">&#125;</span><br><span class="line">/* 打印已建立的数据记录，n是记录总数 */</span><br><span class="line">void Print_list(Element s[], int n) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	if (n &gt; Max_length)return;</span><br><span class="line">	printf(&quot;   XH     Name     C1     C2     C3  \n&quot;);</span><br><span class="line">	printf(&quot;-------------------------------------\n&quot;);</span><br><span class="line">	for (i = 1; i &lt;= n; i++)</span><br><span class="line">		printf(&quot;%4d%10s%7d%7d%7d\n&quot;, s[i].xh, s[i].n, s[i].c1, s[i].c2, s[i].c3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Element s[Max_length];</span><br><span class="line">	int i, records = 0;</span><br><span class="line">	for (i = 1; i &lt;= Max_length; i++) Insert_list(i, s, &amp;records);  /* 创建线性表 */</span><br><span class="line">	Print_list(s, records);  /* 显示学生记录内容*/</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译环境：</p>
<p>visual studio  2022</p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>单向链表的基本操作，创建一个由六个节点组成的单向链表：能够增加、删除、查找、移动节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   NULL  0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linear_chain_node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Linear_chain_node</span>* <span class="title">link</span>;</span></span><br><span class="line">&#125;  NODE;</span><br><span class="line"><span class="comment">/* 建立单链表 */</span></span><br><span class="line">NODE* <span class="title function_">Create_single_chain</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	NODE* head, * p, * q;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	p = (NODE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	p-&gt;data = <span class="number">0</span>;</span><br><span class="line">	p-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">	head = p;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q = (NODE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter Data : &quot;</span>); <span class="built_in">scanf</span>(<span class="string">&quot; % d&quot;</span>, &amp;q-&gt;data);</span><br><span class="line">		q-&gt;link = <span class="literal">NULL</span>;  p-&gt;link = q;  p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 单链表查找节点 */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">Found</span><span class="params">(NODE* head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">	NODE* p;</span><br><span class="line">	<span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	p = head;</span><br><span class="line">	<span class="keyword">while</span> ((p-&gt;link != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;data != x)) &#123; p = p-&gt;link; pos++; &#125;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;link != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> pos;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 插入新结点（第i个结点后）*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(NODE* head, <span class="type">int</span> i, <span class="type">int</span> x)</span> </span><br><span class="line">&#123;</span><br><span class="line">	NODE* p, * q;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>)  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	q = head;</span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((j &lt; i) &amp;&amp; (q != <span class="literal">NULL</span>)) </span><br><span class="line">	&#123; q = q-&gt;link;  j++; &#125;</span><br><span class="line">	<span class="keyword">if</span> (q == <span class="literal">NULL</span>)  </span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	p = (NODE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	p-&gt;data = x;  </span><br><span class="line">	p-&gt;link = q-&gt;link;  </span><br><span class="line">	q-&gt;link = p;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 删除结点p的算法 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(NODE* head, NODE* p)</span> </span><br><span class="line">&#123;</span><br><span class="line">	NODE* q;</span><br><span class="line">	<span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">		head = head-&gt;link;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	q = head;</span><br><span class="line">	<span class="keyword">while</span> ((q-&gt;link != p) &amp;&amp; (q-&gt;link != <span class="literal">NULL</span>)) q = q-&gt;link;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;link == <span class="literal">NULL</span>)  </span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	q-&gt;link = p-&gt;link;  </span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 求线性链表长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(NODE* head)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	NODE* p;</span><br><span class="line">	n = <span class="number">0</span>;  </span><br><span class="line">	p = head;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		n++;</span><br><span class="line">		p = p-&gt;link;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将最大结点移到队尾 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Move</span><span class="params">(NODE* head)</span> &#123;</span><br><span class="line">	NODE* p;   <span class="comment">/* 遍历 */</span></span><br><span class="line">	NODE* s;   <span class="comment">/* p的前驱,末结点 */</span></span><br><span class="line">	NODE* q;   <span class="comment">/* 最大的结点 */</span></span><br><span class="line">	NODE* r;   <span class="comment">/* q的前驱 */</span></span><br><span class="line">	s = head;  </span><br><span class="line">	p = head-&gt;link;  </span><br><span class="line">	q = head;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data &gt; q-&gt;data) </span><br><span class="line">		&#123;</span><br><span class="line">			r = s;  q = p;</span><br><span class="line">		&#125;</span><br><span class="line">		s = p;</span><br><span class="line">		p = p-&gt;link;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (q != s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (q == head) </span><br><span class="line">		&#123; head = head-&gt;link; &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; r-&gt;link = q-&gt;link; &#125;</span><br><span class="line">		s-&gt;link = q;  </span><br><span class="line">		q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出链表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(NODE* head)</span> </span><br><span class="line">&#123;</span><br><span class="line">	NODE* p;</span><br><span class="line">	p = head;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Linear List : &quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) </span><br><span class="line">	&#123; <span class="built_in">printf</span>(<span class="string">&quot; % d\t&quot;</span>, p-&gt;data);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">	p = p-&gt;link; &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	NODE* head, * p, * q;</span><br><span class="line">	<span class="type">int</span> i, j, l, x, n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter node number for creating:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot; % d&quot;</span>, &amp;n);    <span class="comment">/* n=6 */</span></span><br><span class="line">	head = Create_single_chain(n);</span><br><span class="line">	Print(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter data for found:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot; % d&quot;</span>, &amp;x);</span><br><span class="line">	i = Found(head, x);</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;No found node!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Found node at position: %d\n&quot;</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter data and position for inserting: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot; % d % d&quot;</span>, &amp;x, &amp;i);</span><br><span class="line">	n = Insert(head, i, x);</span><br><span class="line">	<span class="keyword">if</span> (n) <span class="built_in">printf</span>(<span class="string">&quot;Insert succ！\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Insert fail!\n&quot;</span>);</span><br><span class="line">	Print(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter position for deleting: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot; % d&quot;</span>, &amp;i);</span><br><span class="line">	p = head;</span><br><span class="line">	j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123; p = p-&gt;link; j++; &#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)  <span class="built_in">printf</span>(<span class="string">&quot;Not delete\n&quot;</span>);</span><br><span class="line">	n = Delete(head, p);</span><br><span class="line">	<span class="keyword">if</span> (n) <span class="built_in">printf</span>(<span class="string">&quot;Delete succ\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;Delete fail\n&quot;</span>);</span><br><span class="line">	Print(head);</span><br><span class="line">	l = Length(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;length = % d\n&quot;</span>, l);</span><br><span class="line">	Move(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Moving max data to tail : \n&quot;</span>);</span><br><span class="line">		Print(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p>用c语言建立单链表并实现：单链表的就地逆置。 将两个非递减有序单链表，合并成一个非递减链表。将两个非递减有序单链表，合并成一个非递增链表。编写一个主函数,调试上述算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义单链表结构体节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个数组转换为单链表</span></span><br><span class="line">ListNode* <span class="title function_">arrayToList</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    head-&gt;val = arr[<span class="number">0</span>];</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ListNode* node = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        node-&gt;val = arr[i];</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        cur = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印单链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表就地逆置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseList</span><span class="params">(ListNode** head)</span> &#123;</span><br><span class="line">    ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* cur = *head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    *head = prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个非递减有序单链表成一个非递减有序单链表</span></span><br><span class="line">ListNode* <span class="title function_">mergeListsAsc</span><span class="params">(ListNode* l1, ListNode* l2)</span> &#123;</span><br><span class="line">    ListNode* dummy = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>;</span><br><span class="line">    dummy-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cur-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cur-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个非递减有序单链表成一个非递增有序单链表</span></span><br><span class="line">ListNode* <span class="title function_">mergeListsDesc</span><span class="params">(ListNode* l1, ListNode* l2)</span> &#123;</span><br><span class="line">    ListNode* dummy = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>;</span><br><span class="line">    dummy-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &gt;= l2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cur-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cur-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseList(&amp;dummy-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> arr2[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    ListNode* l1 = arrayToList(arr1, <span class="number">3</span>);</span><br><span class="line">    ListNode* l2 = arrayToList(arr2, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;l1: &quot;</span>);</span><br><span class="line">    printList(l1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;l2: &quot;</span>);</span><br><span class="line">    printList(l2);</span><br><span class="line"></span><br><span class="line">    ListNode* mergedAsc = mergeListsAsc(l1, l2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;merged in ascending order: &quot;</span>);</span><br><span class="line">    printList(mergedAsc);</span><br><span class="line"></span><br><span class="line">    l1 = arrayToList(arr1, <span class="number">3</span>);</span><br><span class="line">    l2 = arrayToList(arr2, <span class="number">3</span>);</span><br><span class="line">    ListNode* mergedDesc = mergeListsDesc(l1, l2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;merged in descending order: &quot;</span>);</span><br><span class="line">    printList(mergedDesc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>&#x2F;&#x2F; 将一个数组转换为单链表&#x2F;&#x2F;</p>
<p>这段代码定义了一个函数<code>arrayToList()</code>，其目的是将输入的数组转换为链表。函数接收两个参数：一个整数数组<code>arr</code>和一个表示<code>arr</code>长度的整数<code>n</code>。</p>
<p>首先，如果<code>n</code>小于等于0，那么函数返回空指针<code>NULL</code>，否则它会创建一个新的链表头节点，并将数组的第一个元素值存储到头节点的<code>val</code>成员中，将头节点的<code>next</code>指针设置为空指针。</p>
<p>然后，函数使用一个循环遍历数组中的剩余元素。在每次循环中，创建一个新的链表节点，并将当前元素的值存储到该节点的<code>val</code>成员中。将新节点的<code>next</code>指针设置为空指针，并将当前节点的<code>next</code>指针指向该新节点。最后，将当前节点更新为新节点，以便用于下一次循环。</p>
<p>当循环结束后，函数返回链表的头节点。这样，通过调用该函数并传入适当的参数，就可以将一个整数数组转换成一个链表。</p>
<p><strong>Q:</strong>(ListNode*)malloc(sizeof(ListNode));这行是什么意思</p>
<p>**A:**这行代码使用了C语言中的动态内存分配函数<code>malloc()</code>，它在堆上分配了一块大小为<code>sizeof(ListNode)</code>的内存空间，并返回该内存块的起始地址。<code>ListNode*</code>表示这是一个指向<code>ListNode</code>类型对象的指针，因此该代码行创建了一个新的<code>ListNode</code>类型的对象，并将其地址存储在指针变量中。</p>
<h1 id="六"><a href="#六" class="headerlink" title="六"></a>六</h1><p>利用栈实现数据的分类，要求当输入为偶数时进栈1，当输入为奇数时进栈2，最后分别从栈1和栈2输出偶数和奇数序列。&#x2F;2023&#x2F;4&#x2F;24</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">int</span> top, size;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* s, <span class="type">int</span> x)</span><span class="comment">//入栈算法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top &lt; s-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;top = s-&gt;top + <span class="number">1</span>;</span><br><span class="line">        s-&gt;data[s-&gt;top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;OVERFLOW&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack* s)</span><span class="comment">//出栈算法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;top = s-&gt;top - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;UNDERFLOW&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 出错返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(Stack* s)</span> <span class="comment">// 输出栈中所有元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s-&gt;top; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack even_stack, odd_stack;</span><br><span class="line">    even_stack.top = <span class="number">0</span>;</span><br><span class="line">    odd_stack.top = <span class="number">0</span>;</span><br><span class="line">    even_stack.size = <span class="number">100</span>;</span><br><span class="line">    odd_stack.size = <span class="number">100</span>;</span><br><span class="line">    even_stack.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(even_stack.size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    odd_stack.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(odd_stack.size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一组数 (输入0以结束):\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            push(&amp;even_stack, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            push(&amp;odd_stack, <span class="number">2</span>);</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偶数栈： &quot;</span>);</span><br><span class="line">    Print(&amp;even_stack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;奇数栈： &quot;</span>);</span><br><span class="line">    Print(&amp;odd_stack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(even_stack.data);</span><br><span class="line">    <span class="built_in">free</span>(odd_stack.data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七"><a href="#七" class="headerlink" title="七"></a>七</h1><p>Dijkstra algorithm 迪杰斯特拉算法 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_V 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> src, dst;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">edges</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_graph</span><span class="params">(<span class="keyword">struct</span> Graph* graph, <span class="type">int</span> V)</span> &#123;</span><br><span class="line">    graph-&gt;V = V;</span><br><span class="line">    graph-&gt;edges = (<span class="keyword">struct</span> Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Edge) * V * V);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(<span class="keyword">struct</span> Graph* graph, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    graph-&gt;edges[src * graph-&gt;V + dst].src = src;</span><br><span class="line">    graph-&gt;edges[src * graph-&gt;V + dst].dst = dst;</span><br><span class="line">    graph-&gt;edges[src * graph-&gt;V + dst].weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="keyword">struct</span> Graph* graph, <span class="type">int</span> src)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* dist = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * graph-&gt;V);</span><br><span class="line">    <span class="type">int</span>* prev = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * graph-&gt;V);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">        dist[i] = INT_MAX;</span><br><span class="line">        prev[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] &lt; INT_MAX &amp;&amp; (u == <span class="number">-1</span> || dist[i] &lt; dist[u])) &#123;</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] &gt; dist[u] + graph-&gt;edges[u * graph-&gt;V + i].weight) &#123;</span><br><span class="line">                dist[i] = dist[u] + graph-&gt;edges[u * graph-&gt;V + i].weight;</span><br><span class="line">                prev[i] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The shortest distance from %d to %d is %d\n&quot;</span>, src, i, dist[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(dist);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> <span class="title">graph</span>;</span></span><br><span class="line"></span><br><span class="line">    init_graph(&amp;graph, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    add_edge(&amp;graph, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    add_edge(&amp;graph, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    add_edge(&amp;graph, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    add_edge(&amp;graph, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">    add_edge(&amp;graph, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">    add_edge(&amp;graph, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    dijkstra(&amp;graph, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八"><a href="#八" class="headerlink" title="八"></a>八</h1><p>实验：最短路径<br>利用图的最短路径原理为用户提供路径咨询，掌握求最短路径的算法并编程实现<br>设计一个旅游景点导游模拟程序，为来访的客人提供景点最短路径的信息查询服务，任意选取n个城市，构成一个有向带权图，图中顶点表示城市，边上的权值表示两点间的距离，根据用户指定的始点和终点输出相应的最短路径</p>
<p>&#x2F;2023&#x2F;5 22</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES];</span><br><span class="line"><span class="type">int</span> dist[MAX_VERTICES];</span><br><span class="line"><span class="type">int</span> visited[MAX_VERTICES];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> num_vertices)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化距离数组和访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_vertices; i++) &#123;</span><br><span class="line">        dist[i] = INT_MAX;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起点到自身的距离为0</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行n-1次循环（n为顶点数），每次找出一个距离起点最近的未访问顶点，并更新它的邻接顶点的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_vertices - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_dist = INT_MAX;</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出一个距离起点最近的未访问顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num_vertices; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; min_dist) &#123;</span><br><span class="line">                min_dist = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新与u相邻的顶点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; num_vertices; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] != <span class="number">-1</span> &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最短路径的长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从顶点 %d 到顶点 %d 的最短距离为 %d\n&quot;</span>, start, end, dist[end]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定最短路径上的顶点</span></span><br><span class="line">    <span class="type">int</span> path[MAX_VERTICES];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> current = end;</span><br><span class="line">    path[index++] = current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != start) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_vertices; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i][current] != <span class="number">-1</span> &amp;&amp; dist[i] + graph[i][current] == dist[current]) &#123;</span><br><span class="line">                current = i;</span><br><span class="line">                path[index++] = current;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最短路径上的顶点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从顶点 %d 到顶点 %d 的最短路径为：: &quot;</span>, start, end);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 读入图的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入[顶点数][边数]&quot;</span>);</span><br><span class="line">    <span class="type">int</span> num_vertices;</span><br><span class="line">    <span class="type">int</span> num_edges;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;num_vertices, &amp;num_edges);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 初始化图的邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_vertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num_vertices; j++) &#123;</span><br><span class="line">            graph[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入边的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_edges; i++) &#123;</span><br><span class="line">        <span class="type">int</span> source, dest, weight;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入数据，参数分别是：[起点][终点][两点间的距离]\n&quot;</span>);</span><br><span class="line">        scanf_s(<span class="string">&quot;%d%d%d&quot;</span>, &amp;source, &amp;dest, &amp;weight);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;___________________________________ \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|                                  |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|    %d    ----%d-----&gt;   %d          |\n&quot;</span>, source, weight, dest);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|__________________________________| \n&quot;</span>);</span><br><span class="line">        graph[source][dest] = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dijkstra(<span class="number">0</span>, num_vertices - <span class="number">1</span>, num_vertices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E5%9B%BE%E4%B9%A6%E6%8E%A8%E8%8D%90/">← Next 数据结构课程图书推荐</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/03/04/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E5%8E%86%E7%A8%8B/">关于此博客 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://i.328888.xyz/2023/03/11/sI82d.png" alt="Logo"></a><h1 id="Dr"><a href="/">xuan tu</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">一</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C"><span class="toc-number">2.</span> <span class="toc-text">二</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89"><span class="toc-number">3.</span> <span class="toc-text">三</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B"><span class="toc-number">4.</span> <span class="toc-text">四</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94"><span class="toc-number">5.</span> <span class="toc-text">五</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD"><span class="toc-number">6.</span> <span class="toc-text">六</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83"><span class="toc-number">7.</span> <span class="toc-text">七</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB"><span class="toc-number">8.</span> <span class="toc-text">八</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>